**如果有一天我们要把 Element Plus 换成 Ant Design，或者我们要把全站的按钮都改个颜色，你会一个个页面去改，还是只改一个地方？”**

我们要回答的核心关键词是：**二次封装** 和 **透传 ($attrs)**。 ---------- 层次架构

### 怎么封装？（核心代码 + 讲解）

这里以封装一个 **“通用按钮 (MyButton)”** 为例，假设我们基于 Element Plus 的 el-button。

#### 核心技术点 1：透传属性与事件 (v-bind="$attrs")

这是 Vue 3 的神器。你不需要一个个去定义 props（什么 size, type, disabled...），直接用 $attrs 就能把父组件传进来的所有东西，**原封不动**地甩给第三方组件。

#### 核心技术点 2：插槽透传 (< slot >)

不仅要传属性，还要把按钮里的文字、图标传进去。

#### 1. 封装组件 MyButton.vue，对第三方组件库再封装，明确你的目的： Element Plus 换成 Ant Design，你会一个个页面去改，还是只改一个地方？”

```
<script setup>
import { useAttrs } from 'vue'

// 1. 如果有需要特殊处理的属性，可以用 defineProps 接住
// 比如：我们公司默认按钮都是 'primary' 类型的
const props = defineProps({
  type: {
    type: String,
    default: 'primary' // 设置默认值
  }
})

// 2. $attrs 包含了父组件传来的所有“非 props”属性（比如 onClick, disabled, size, class 等）
											--- 因为不是通过v-bind传过来的，而单纯只是size=“large”
											
											
// 在模板里用 v-bind="$attrs" 自动绑定
</script>

<template>
  <div class="my-btn-wrapper">
    <!-- 
      核心代码：
      1. :type="type" -> 使用我们要控制的默认属性
      2. v-bind="$attrs" -> 把剩下的属性（比如 @click, size）全部透传给 el-button
    -->
    <el-button :type="type" v-bind="$attrs">
      <!-- 3. 插槽透传：让父组件能写文字或图标 -->
      <slot></slot>
    </el-button>
  </div>
</template>

<style scoped>
/* 可以在这里统一修改样式，比如加个阴影 */
.el-button {
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
</style>
```

#### 2. 父组件如何使用

```
<template>
  <!-- 
    场景：
    1. 我没传 type，它会自动变成 'primary' (封装的功劳)
    2. 我传了 size="large" 和 @click，它会自动传给内部的 el-button ($attrs 的功劳)
    3. 我写了 '提交'，它会显示在插槽位置
  -->
  <MyButton size="large" @click="handleClick">
    提交
  </MyButton>
  <!-- 也可以覆盖默认值 -->
  <MyButton type="danger">删除</MyButton>
</template>
```



### 三、 进阶：怎么封装 el-input 这种带 v-model 的？

如果面试官追问：“那输入框怎么封装？v-model 怎么处理？”
这时候要用 **computed** 或者 **defineModel (Vue 3.4+)**。

#### 方案：使用 computed 实现双向绑定透传

**封装组件 MyInput.vue：**（二次封装第三方组件库的el-input）

```
<script setup>
import { computed } from 'vue'

// 1. 接收父组件的 v-model 值
const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])

// 2. 用 computed 做个中转
const proxyValue = computed({
  get() {
    return props.modelValue
  },
  set(val) {
    // 当输入框内容变了，通知父组件更新
    emit('update:modelValue', val)
  }
})
</script>

<template>
  <!-- 核心：把 el-input 的 v-model 绑定到我们的计算属性上 -->
  <el-input v-model="proxyValue" v-bind="$attrs">
    <!-- 如果 el-input 有 slot，这里也可以继续透传，稍微复杂点，面试一般不问这么细 -->
  </el-input>
</template>
```

v-model  就是 v-bind 和 v-on的结合语法糖

### 💡 总结（面试拿分点）

如果问到封装第三方组件，一定要说到这 3 点：

1. **透传属性：** “我使用 **v-bind='$attrs'** 来实现属性和事件的透传，这样我就不用把第三方组件的 Props 全都重新写一遍，非常省事。”
2. **默认配置：** “我会利用 defineProps 设置默认值（比如默认按钮颜色、默认表格分页大小），来减少重复代码。”
3. **插槽支持：** “我会保留 **< slot >**，确保组件的内容依然可以灵活定义。”

**记住这个 v-bind="$attrs"，这是封装组件的灵魂！**







**不用背，也不是去官网查的，而是“偷”来的（通过编辑器找出来的）。**

Axios 这种优秀的库，是用 TS 写的（或者自带了类型定义文件 .d.ts）。我教你**三招**，让你像老手一样瞬间找到类型。

------



### 第一招：Ctrl + 鼠标左键（“偷”类型大法）

这是最常用的方法。当你引入 axios 时，直接对着它点击。

1. **操作：** 在 VS Code 里，按住 Ctrl (Mac 是 Cmd)，然后鼠标**左键点击**代码里的 axios 或者 .create 方法。
2. **结果：** 这一跳，就会跳进 node_modules/axios/index.d.ts 文件里。
3. **发现：** 你会看到满屏的 export interface ...。
   - 搜一下 config，你就会发现它的类型叫 AxiosRequestConfig。
   - 搜一下 response，你就会发现它的类型叫 AxiosResponse。

**实操演示：**
当你写 axios.create(config) 时，鼠标悬停在 create 上，VS Code 会弹窗提示：
(method) AxiosStatic.create(config?: CreateAxiosDefaults<any>): AxiosInstance
这里你就知道了，返回值是 AxiosInstance。

------



### 第二招：猜命名规律（IntelliSense 自动提示）

大部分库的类型命名都非常有规律，通常是 **库名 + 作用**。

比如 Axios：

- 你要写**请求配置**？试着敲 AxiosReq... -> 自动提示 AxiosRequestConfig。
- 你要处理**响应结果**？试着敲 AxiosRes... -> 自动提示 AxiosResponse。
- 你要定义**实例**？试着敲 AxiosIns... -> 自动提示 AxiosInstance。
- 你要处理**错误**？试着敲 AxiosErr... -> 自动提示 AxiosError。

**VS Code 的联想功能**是你最好的老师。




这是一个非常棒的**实战问题**！很多转 TS 的新手都会懵：“这 AxiosRequestConfig 这种又长又怪的名字，你们是怎么知道的？是背下来的吗？”

答案是：**不用背，也不是去官网查的，而是“偷”来的（通过编辑器找出来的）。**

Axios 这种优秀的库，是用 TS 写的（或者自带了类型定义文件 .d.ts）。我教你**三招**，让你像老手一样瞬间找到类型。

------



### 第一招：Ctrl + 鼠标左键（“偷”类型大法）

这是最常用的方法。当你引入 axios 时，直接对着它点击。

1. **操作：** 在 VS Code 里，按住 Ctrl (Mac 是 Cmd)，然后鼠标**左键点击**代码里的 axios 或者 .create 方法。
2. **结果：** 这一跳，就会跳进 node_modules/axios/index.d.ts 文件里。
3. **发现：** 你会看到满屏的 export interface ...。
   - 搜一下 config，你就会发现它的类型叫 AxiosRequestConfig。
   - 搜一下 response，你就会发现它的类型叫 AxiosResponse。

**实操演示：**
当你写 axios.create(config) 时，鼠标悬停在 create 上，VS Code 会弹窗提示：
(method) AxiosStatic.create(config?: CreateAxiosDefaults<any>): AxiosInstance
这里你就知道了，返回值是 AxiosInstance。

------



### 第二招：猜命名规律（IntelliSense 自动提示）

大部分库的类型命名都非常有规律，通常是 **库名 + 作用**。

比如 Axios：

- 你要写**请求配置**？试着敲 AxiosReq... -> 自动提示 AxiosRequestConfig。
- 你要处理**响应结果**？试着敲 AxiosRes... -> 自动提示 AxiosResponse。
- 你要定义**实例**？试着敲 AxiosIns... -> 自动提示 AxiosInstance。
- 你要处理**错误**？试着敲 AxiosErr... -> 自动提示 AxiosError。

**VS Code 的联想功能**是你最好的老师。

------



### 第三招：Axios 封装的标准 TS 模板（直接抄这个）

既然你问到了 Axios 的封装，**Axios 版本更新后（v1.0+）**，类型有点小变化。这里给你一份**标准、现代的 TS 封装代码**，面试官看到这个会觉得你很专业。

**关键类型有这 4 个：**

1. AxiosInstance: Axios 实例的类型。
2. AxiosResponse: 响应体的类型。
3. InternalAxiosRequestConfig: **(注意)** 新版拦截器里，请求配置必须用这个，不然会报错。
4. AxiosError: 捕获错误时的类型。



### 如果库没有自带类型怎么办？”

这是一个常见的追问。

**你的回答：**

1. **先找 @types：** “很多老库（比如 jQuery, lodash）本身不是 TS 写的，我会去安装社区维护的类型包。比如 npm install @types/lodash -D。”
2. **自己写声明文件：** “如果连 @types 都没有，我会在 src 下建一个 types/xxx.d.ts，简单写一个 declare module 'xxx' 来解决报错，防止阻碍开发。”

### 总结

不用去官网搜，**Ctrl + 点击** 源码，或者靠 **VS Code 自动联想**，是最高效的方法。对于 Axios，记住 AxiosInstance 和 InternalAxiosRequestConfig 这两个最常用的就够了！





' abc '.match(/\babc\b/) **不会返回 null**，它会**匹配成功**，结果是 ['abc']。

你的理解中：“有两个 \b，只要有一个匹配失败则返回 null” —— **这句话本身是对的**。正则表达式是串行匹配的，中间任何一个环节断了，整个匹配就失败。

**但是**，在你给出的这个例子 ' abc ' 中，两个 \b **都匹配成功了**，所以结果不是 null

#### 什么是 \b？

正如你所说，\b 是单词边界。它的判断标准是：**一边是单词字符 (\w)，另一边是非单词字符 (\W，包括空格、标点、开头或结尾)**。

#### 2. 分析字符串 ' abc '

让我们看看这个字符串：

- 第1个字符：空格 (非单词字符 \W)
- 第2个字符：a (单词字符 \w)
- 第3个字符：b (单词字符 \w)
- 第4个字符：c (单词字符 \w)
- 第5个字符：空格 (非单词字符 \W)

#### 3. 匹配过程

正则 /\babc\b/ 的执行步骤如下：

- **第一个 \b（abc左边）：**
  - 正则引擎检查字符 a 的左边。
  - 左边是**空格**（非单词），右边是 **a**（单词）。
  - 满足“一侧是 \w，另一侧非 \w”。
  - ✅ **第一个 \b 匹配成功。**
- **中间的 abc：**
  - 匹配 abc 字符。
  - ✅ **匹配成功。**
- **第二个 \b（abc右边）：**
  - 正则引擎检查字符 c 的右边。
  - 左边是 **c**（单词），右边是**空格**（非单词）。
  - 满足“一侧是 \w，另一侧非 \w”。
  - ✅ **第二个 \b 匹配成功。**

**结果：** 全部通过，匹配成功。



### 什么时候会返回 null？（你的假设情况）

你提到的“一个匹配失败则返回 null”，会发生在以下这种字符串里：

**例子 1：左边没有边界**

```
// 字符串："xabc "
// 'x' 是单词字符，'a' 也是单词字符。
// 'a' 的左边是 'x'，两边都是单词字符，所以不存在边界 \b。
'xabc '.match(/\babc\b/); 
// 结果：null
```

**例子 2：右边没有边界**

```
// 字符串：" abc1"
// 'c' 是单词字符，'1' 也是单词字符。
// 'c' 的右边是 '1'，两边都是单词字符，不存在边界 \b。
' abc1'.match(/\babc\b/); 
// 结果：null
```

### 总结

你对正则逻辑的理解（有一个失败全盘皆输）是对的，但你可能误判了 ' abc ' 这个字符串的情况：**空格也是非单词字符**，所以空格和字母之间是有边界的。





**axios.create(config) 不返回 Promise。**

这是一个非常重要的概念区分，千万别搞混了：

### 1. axios.create(config) 返回什么？

- **返回类型：** 它返回的是一个 **对象 (AxiosInstance)**。
- **特性：** 这是一个**同步**操作。就像你 new Object() 一样，它立即就完成了，不需要等待，所以不是 Promise。
- **类比：** 这就像你去商店 **“买手机”**。你付钱，店员立马把手机（实例）给你。

### 2. 什么时候才返回 Promise？

只有当你**使用这个实例去发请求**的时候，才会返回 Promise。

- **比如：** instance.request()、instance.get()、instance.post()。
- **类比：** 这就像你拿到手机后 **“打电话”**。拨出号码后，你需要**等待**对方接听（异步），这就是 Promise。



### 总结

- **造工具 (axios.create)**：拿到的是 **工具 (对象)**，不用等。
- **用工具 (instance.get)**：拿到的是 **承诺 (Promise)**，要等结果。





```
str.padStart(targetLength, padString)
```

- **targetLength**：目标长度（你希望字符串最终有多长）。
  - 如果原字符串长度已经 >= 这个长度，则不填充，直接返回原字符串。
- **padString** (可选)：用来填充的字符串。
  - 默认为空格 ' '。
  - 如果填充字符串太长，会被截断。

### 最经典的使用场景（面试/实战必用）

#### 场景一：时间/日期格式化（补 0）

这是 padStart 最最常用的地方。比如月份是 9，但后端要求发 09；或者显示倒计时 00:05。

```
const month = "9";
const day = "5";

// 目标长度为2，不够就在前面补 '0'
const fMonth = month.padStart(2, "0"); // "09"
const fDay = day.padStart(2, "0");     // "05"
```



#### 场景二：手机号/银行卡脱敏（隐藏信息）

比如只显示最后 4 位，前面全部用 * 代替。

```
const phone = "13812345678";
const last4 = phone.slice(-4); // 拿到 "5678"

// 目标长度11，前面用 '*' 填满
const maskPhone = last4.padStart(11, "*"); 

console.log(maskPhone); // "*******5678"
```



### 特殊情况（细节坑点）

**情况 A：原字符串本来就比目标长度长**
padStart 不会删除东西，它会直接忽略，什么都不做。

```
"hello".padStart(3, "a"); 
// 结果："hello" (长度是5，已经超过3了，不动)
```

**情况 B：填充字符太长了**
它会截取填充字符的左边部分，刚好填满为止。

```
"c".padStart(4, "ab"); 
// 结果："abac" 
// 解释：本来想填 "abab"，但长度只能到4，所以最后一个 b 被砍掉了。
```

**情况 C：没传第二个参数**
默认补空格。

```
"5".padStart(3); 
// 结果："  5" (前面两个空格)
```



当 v-show 本质是切换 display: none，这会改变元素的几何信息（宽高），导致文档流发生变化，其下方的元素位置也会变动，所以必然触发回流。

我们通常说 v-show 性能比 v-if 好，是因为 v-show 只是修改 CSS 属性，避免了 v-if 那种频繁**创建和销毁 DOM 节点**的开销。

只有像 visibility: hidden 这种虽然隐藏但保留占位的属性，才只会触发重绘而不触发回流。”





### 写法一：直接监听对象

```
watch(words, (newVal, oldVal) => {
  console.log("watch", newVal, oldVal)
})
```

- **现象：** newVal 和 oldVal **是一模一样的**。
- **原因：**
  - Vue 直接监听的是这个对象的**引用（Reference）**。
  - 当对象内部的属性发生变化时，对象本身的引用并没有变（内存地址没变）。
  - 因为 Vue 为了性能，默认不会保留修改前的“快照”副本。所以当回调函数执行时，newVal 和 oldVal 指向的都是**同一个已经变了的当前对象**。
- **特性：** 对于 reactive 对象，这种写法**默认是深度监听（Deep Watch）**的，不需要加 { deep: true }。

**输出示例：**

```
// 假设 words.text 从 "a" 变成了 "b"
// 输出：
watch {text: "b"} {text: "b"}  // 你无法获取原来的 "a"
```

### 2. 写法二：监听一个 Getter 函数（返回解构的新对象）

```
watch(() => ({...words}), (newVal, oldVal) => {
  console.log("watch", newVal, oldVal)
})
```

- **现象：** **能拿到正确的 oldVal**。
- **原因：**
  - () => ({...words}) 是一个 getter 函数。每当依赖变化，这个函数就会重新执行。
  - {...words} 使用了**解构赋值**，它创建了一个**新的对象**（浅拷贝）。
  - Vue 监听的是这个函数的**返回值**。
  - 当数据变化时，Vue 会把“上一次函数返回的对象”作为 oldVal，把“这一次函数返回的新对象”作为 newVal。因为这是两个不同的内存地址，所以旧值被保留下来了。
- **特性：** 这种写法通常是**浅层监听**。如果 words 内部还有嵌套对象，且嵌套对象的属性变了，除非你加 { deep: true }，否则可能监听不到（取决于解构的层级）。

| 对比维度            | watch(words)                       | watch(() => ({...words}))                            |
| ------------------- | ---------------------------------- | ---------------------------------------------------- |
| **oldVal 是否准确** | ❌ 否 (新旧值相同)                  | ✅ 是 (能拿到旧值)                                    |
| **内存开销**        | 小 (不创建新对象)                  | 稍大 (每次变化都会创建新对象)                        |
| **监听深度**        | 默认深度监听                       | 默认浅层 (依赖解构层级)，通常用于监听第一层属性      |
| **使用场景**        | 只需要知道“变了”，不关心“原来是啥” | 需要拿新旧值做对比（例如：判断数值是变大还是变小了） |

**什么时候用哪种？**

1. **大多数情况：** 用第一种 watch(words)。因为它代码短，而且大多时候我们只关心当前的最新值去发请求或做逻辑。
2. **特殊情况：** 如果你的业务逻辑依赖于 **“以前的状态”**（比如：撤销操作、或者记录变更日志），必须用第二种写法，手动解构一个副本出来。





1. **必须用 watch 的情况：**
   - 你需要拿到 **旧值 (Old Value)** 做对比（比如：如果不等于旧值才发请求）。
   - 你需要**精确控制**监听谁（比如函数里用到了 5 个变量，但我只想监听其中 1 个的变化）。
   - 你不希望一开始就执行（懒执行）。
2. **推荐用 watchEffect 的情况：**
   - **请求数据：** 页面加载时要发请求，参数变了也要重新发请求（最经典场景）。
   - **依赖很多：** 你的逻辑里依赖了 a, b, c, d 四个变量，写 watch([a,b,c,d], ...) 太累了，用 watchEffect 自动收集最方便。

### 总结

- **watch**：我盯着**特定的人**，他动了我才动。（精准、可拿旧值）
- **watchEffect**：我盯着**这间屋子**，只要我用到的东西动了，我马上动。（省事、自动、立即执行）



#### 方式 A：使用 watch (手动挡)

你必须明确写出监听 userID，并且为了让页面刚进来就请求一次，还得加 immediate。

```
const userID = ref(1)

watch(userID, (newID) => {
  console.log('发请求拿用户:', newID)
}, { immediate: true }) // 👈 必须手动开启立即执行
```

#### 方式 B：使用 watchEffect (自动挡)

你不需要告诉它监听谁，也不用写 immediate。只要你在函数里用了 userID.value，它自己知道。

```
const userID = ref(1)

watchEffect(() => {
  // 👇 它发现你用了 userID.value，就会自动把它加入监听列表
  console.log('发请求拿用户:', userID.value)
})
```

------



### 3. watchEffect 的高级用法（面试加分项）

面试官可能会问：“如果我在 watchEffect 里发请求，请求还没回来参数又变了，怎么取消上一次请求？” 或者 “怎么清除定时器？”

这就要用到 **副作用清除 (onInvalidate)**。

**场景代码：搜索框防抖/取消请求**

```
import { ref, watchEffect } from 'vue'

const keyword = ref('')

watchEffect((onInvalidate) => {
  // 1. 获取当前的值
  const kw = keyword.value
  
  // 模拟发请求的定时器
  const timer = setTimeout(() => {
    console.log('发送搜索请求:', kw)
  }, 1000)

  // 2. onInvalidate：副作用清除函数
  // 什么时候执行？ -> 当依赖变了，准备重新执行下一次 watchEffect 之前，会先执行这个。
  // 作用：清理上一次留下的垃圾（比如定时器、未完成的请求）。
  onInvalidate(() => {
    clearTimeout(timer)
    console.log('上一次的请求被取消了/定时器被清除了')
  })
})

```





#### 1. 选择器与 DOM 操作（最基础）

- **选择器：** $('#id'), $('.class'), $('div > p')。
- **获取/修改内容：**
  - html() —— 相当于 innerHTML
  - text() —— 相当于 innerText
  - val() —— 相当于 value (表单用)
- **属性操作：**
  - attr('href', 'url') / prop('checked', true)
  - **考点：** attr 和 prop 区别？
    - **prop**：用于布尔值属性（如 checked, selected, disabled），操作 DOM 属性。
    - **attr**：用于自定义属性或 HTML 标签上的属性。

#### 2. 事件委托（Top 1 必考题）

**问：** 页面上动态新增的 <li>，原来的 click 事件不生效怎么办？
**答：** 使用**事件委托**。利用事件冒泡原理，把事件绑定在父元素上。

```
// ❌ 错误：只对页面加载时存在的 li 有效
$('li').click(function() { ... });

// ✅ 正确（推荐）：绑定在父元素 ul 上，'li' 是过滤器
$('ul').on('click', 'li', function() {
    // this 指向被点击的那个 li
    console.log($(this).text());
});
```





####  jQuery 的生命周期

**问：** $(document).ready() 和 window.onload 有什么区别？

- **$(document).ready()** (简写 $(function(){}))：**DOM 结构加载完**就执行，不用等图片下载完。**快**。可以写多个。
- **window.onload**：要等**所有资源（图片、CSS、JS）**都下载完才执行。**慢**。只能写一个（后面的覆盖前面的）。



 jQuery 和 Vue 最大的区别是什么？

- **jQuery：** 是**命令式**编程。我要手动找到 DOM，手动修改 DOM。关注点在 **DOM** 上。
- **Vue：** 是**声明式/响应式**编程。我只修改数据，Vue 帮我更新 DOM。关注点在 **数据** 上。







UniApp 有三套生命周期，面试必问：

- **应用生命周期（App.vue）：**
  - onLaunch：App 启动（只触发一次，做登录检查、版本更新）。
  - onShow：App 从后台切回前台。
- **页面生命周期（页面文件）：** **（最重要！）**
  - **onLoad(options)**：页面加载。**核心考点：页面传参在这里接收 options.id。**
  - onShow：页面显示（每次切回来都触发）。
  - onPullDownRefresh：下拉刷新。
  - onReachBottom：触底（做分页加载）。
- **组件生命周期（Components）：**
  - 同 Vue 是一样的（mounted, created 等）





#### nvue (Native Vue) —— 进阶题

如果问到：“App端感觉 Vue 渲染不够流畅怎么办？”
**答：** 使用 **nvue**。

- 它是基于 Weex 的，底层是用**原生引擎渲染**的（不是 WebView），性能接近原生 App。
- 缺点是 CSS 支持受限（只能用 Flex 布局，不能用复杂的 CSS 选择器）。 





 子元素浮动了，父元素高度塌陷（变成0）了怎么办？
**答：** 给父元素加个伪元素（clearfix）。

```
.clearfix::after {
    content: "";
    display: block;
    clear: both;
}
```

#### 4. Flex 常用属性

- flex-wrap: wrap; —— 换行。
- justify-content: space-between; —— 两端对齐（中间留空）。
- flex: 1; —— 剩余空间全归我（用于左边固定宽度，右边自适应）。





#### $(this) 和 this 的区别

**问：** 在点击事件里，this 是什么？

- **this**：是原生的 DOM 对象（比如 <div id="box">）。不能用 jQuery 的方法。
- **$(this)**：把原生对象包装成了 jQuery 对象，这样才能调用 .css(), .hide(), .animate()。

#### 2. 查找元素 (DOM 遍历) —— **非常实用**

面试官可能会问：“怎么找到当前按钮隔壁的那个输入框？”

- $('.box').find('span')：找**子孙**（往下找）。
- $('.box').children('span')：只找**亲儿子**。
- $(this).parent()：找**亲爹**。
- $(this).parents('.container')：找**祖宗**。
- $(this).closest('li')：**（神器）** 往上找最近的一个 li（包括自己）。
- $(this).siblings()：找**兄弟姐妹**（除了自己）。

#### 3. 链式调用

**问：** 为什么 jQuery 可以 $('div').css(...).show().html(...) 一直点下去？
**答：** 因为 jQuery 的每个方法（如 css, show）执行完后，都会 **return this**（返回当前 jQuery 对象本身）。

#### 4. 扩展插件 ($.extend)

**问：** 怎么给 jQuery 增加自定义方法？
**答：** 使用 $.fn.extend。

```
$.fn.extend({
    // 定义一个变红的方法
    turnRed: function() {
        // 这里的 this 就是调用这个方法的 jQuery 对象
        $(this).css('color', 'red');
        return this; // 保持链式调用
    }
});
// 用法：$('div').turnRed();
```

#### 5. 阻止冒泡与默认行为

```
$('a').click(function(e) {
    e.stopPropagation(); // 阻止冒泡（不让父元素触发点击）
    e.preventDefault();  // 阻止默认行为（比如 a 标签不跳转）
    
    // 或者直接写一句：
    // return false; // 既阻止冒泡，又阻止默认行为
});
```





讲一下 UniApp 做微信登录的流程？
**答：** (这套话术背下来)

1. 前端调用 **uni.login()**，拿到 provider (服务商) 和 **code** (临时登录凭证)。
2. 前端把 code 发送给**后端接口**。
3. 后端拿着 code 去找微信服务器换取 openid 和 session_key。
4. 后端生成一个 token 返回给前端。
5. 前端把 token 存入 **uni.setStorageSync('token', ...)**。
6. 以后每次请求，在 header 里带上这个 token。





- px: 死的，绝对单位。
- em: 相对于**父元素**字体大小。
- rem: 相对于**根元素(html)**字体大小（移动端 H5 常用）。
- vw: 相对于视口宽度（1vw = 1% 屏幕宽）。
- rpx: **UniApp/小程序专用**。750rpx = 屏幕宽度。自动适配，最方便。







 Less 还是 SCSS，在 UniApp 中使用的核心目的都是为了**“偷懒”**和**“好维护”**：

1. **嵌套写法 (Nesting) —— 最爽的功能**

   - **原生 CSS：** .header .nav .item { color: red; } (写起来很累，层级一多容易乱)。

   - **Less/SCSS：**

     ```
     .header {
         .nav {
             .item { color: red; }
         }
     }
     ```

     结构清晰，跟 HTML 结构一一对应。

2. **变量 (Variables) —— 一键换肤**

   - 定义一个“主题色”，整个 App 几百个页面都用这个变量。老板说要从“红”变成“蓝”，你只需要改这一行代码。

3. **混合 (Mixins) —— 复制粘贴代码块**

   - 比如“文本超出省略号”这段代码有 3 行，你可以把它封装成一个 Mixin，哪里要用就调用一下，不用重复写。

------



### 二、 Less 和 SCSS 的区别 (面试考点)

虽然功能差不多，但语法有明显不同。**在 UniApp 中，SCSS 更常用（官方推荐）。**

#### 1. 声明变量的符号不同 (最直观的区别)

- **Less：** 使用 **@** 符号。

  ```
  @theme-color: #007aff;
  .box { color: @theme-color; }
  ```

- **SCSS：** 使用 **$** 符号。

  ```
  $theme-color: #007aff;
  .box { color: $theme-color; }
  ```

#### 2. 逻辑能力不同 (SCSS 更强)

- **SCSS：** 真的像写代码，支持 if/else 判断，支持 for 循环。

  ```
  // SCSS 循环生成 margin 类名
  @for $i from 1 through 5 {
    .m-#{$i} { margin: $i * 10px; }
  }
  ```

- **Less：** 逻辑比较弱，以前靠递归模拟循环，虽然现在也有了，但不如 SCSS 直观。

#### 3. 混合 (Mixin) 的语法不同

- **Less：** 直接把类名当函数用。

  ```
  .center { text-align: center; }
  .box { .center(); } // 直接调用
  ```

- **SCSS：** 语法更严谨，用 @mixin 定义，用 @include 引用。

  ```
  @mixin center { text-align: center; }
  .box { @include center; } // 必须写 @include
  ```

### 三、 UniApp 中的特殊情况 (重要实战点)

如果你做 UniApp 开发，我**强烈建议你选 SCSS**，理由如下：

#### 1. uni.scss 全局文件

当你创建 UniApp 项目时，根目录下会自动生成一个 **uni.scss** 文件。

- **作用：** 这里面预置了很多官方定义的变量（如 $uni-color-primary）。
- **优势：** 这个文件是**全局自动引入**的。你在任何一个 .vue 文件的 <style lang="scss"> 里，都可以直接使用这里面的变量，**不需要** import。
- **注意：** 如果你用 Less，就享受不到这个官方默认的便利，必须自己手动配置全局文件。

#### 2. 插件市场生态

UniApp 插件市场里（比如 uView UI、Uni-ui），绝大多数优秀的组件库都是用 **SCSS** 写的。如果你也用 SCSS，修改它们的源码或覆盖样式会非常丝滑。

------

### “Less 和 SCSS 有什么区别？你在 UniApp 里用哪个？”

**你的回答：**

> “这两个都是 CSS 预处理器，核心作用都是支持**嵌套写法**、**变量**和**Mixin**，能大大提高 CSS 的编写效率和维护性。
>
> **区别方面：**
>
> 1. 最明显的是**变量符号**不同，Less 用 @，SCSS 用 $。
> 2. **编程能力**上 SCSS 更强，支持更复杂的循环和逻辑判断。
>
> **在 UniApp 项目中：**
> 我主要使用 **SCSS**。
> 因为 UniApp 官方默认提供了 uni.scss 全局文件，里面内置了很多系统变量，只有用 <style lang="scss"> 才能直接使用这些全局变量，而且配合 uView 等组件库也更方便。





```
.ellipsis {
  width: 200px;
  
  /* 1. 强制不换行 */
  white-space: nowrap;
  
  /* 2. 超出部分隐藏 */
  overflow: hidden;
  
  /* 3. 超出部分显示省略号 */
  text-overflow: ellipsis;
}
```

