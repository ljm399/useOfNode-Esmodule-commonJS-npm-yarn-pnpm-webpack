### 第一梯队：围绕你发的项目（重中之重）

1. **项目难点：**
   - **问：** “在这个项目中，你遇到的最大的难点是什么？你是怎么解决的？”
   - **准备：** 千万不要说“没遇到困难”。准备一个具体的功能点（比如：图片懒加载、跨域问题、复杂的组件通信、移动端适配等），描述**问题现象 -> 你的分析 -> 解决方案 -> 最终结果**。
2. **技术选型：**
   - **问：** “我看你用了Vue/React（根据你项目），为什么要选这个框架？或者为什么要用这个插件？”
   - **准备：** 说出框架的优势（如：Vue上手快/双向绑定，React生态好/灵活性高），或者说“这是目前社区最流行的方案”。
3. **代码细节（防伪）：**
   - **问：** “打开你的某个文件，问这行代码（比如一个useEffect或者watch）的作用是什么？”
   - **准备：** **今晚务必把自己提交的代码通读一遍**，特别是那些也是你从网上抄来/GPT生成的代码，一定要搞懂逻辑！
4. **项目优化：**
   - **问：** “如果让你现在优化这个项目，你会从哪些方面入手？”
   - **准备：** 提到关键词：代码压缩、图片懒加载、路由懒加载、减少HTTP请求、组件复用。

------



### 第二梯队：前端基础八股文（实习生必考）

#### HTML/CSS

1. **盒子模型：** 标准盒模型（content-box）和怪异盒模型（border-box）的区别？
2. **水平垂直居中：** 给一个div，怎么让它在屏幕中间？（**必背：** Flex布局 justify-content: center; align-items: center;，或者绝对定位+transform）。
3. **Flex布局：** 常用属性有哪些？（主轴、交叉轴）。
4. **BFC（块级格式化上下文）：** 听说过吗？怎么触发？解决了什么问题？（清除浮动、防止margin重叠）。

#### JavaScript（核心）

1. **ES6新特性：** var、let、const的区别？箭头函数和普通函数的区别？
2. **数据类型：** 基本数据类型有哪些？如何判断数组？
3. **Promise：** 它是做什么的？解决了什么问题（回调地狱）？async/await 怎么用？
4. **闭包：** 什么是闭包？有什么优缺点？（防抖节流通常会用到闭包，可以结合说）。
5. **深拷贝 vs 浅拷贝：** 区别是什么？怎么实现一个深拷贝（JSON.parse(JSON.stringify()) 或 递归）。
6. **数组操作：** map、filter、forEach、reduce 的区别？



### 第四梯队：计算机网络与浏览器（加分项）

1. **输入URL到页面展示发生了什么？** （这是一个经典大题，即使背不全，也要知道：DNS解析 -> 建立TCP连接 -> 发送HTTP请求 -> 接收响应 -> 浏览器解析HTML/CSS/JS -> 渲染页面）。
2. **HTTP状态码：** 200（成功）、301/302（重定向）、403（禁止）、404（未找到）、500（服务器错误）。
3. **跨域：** 什么是跨域？怎么解决？（CORS、JSONP、代理）。





- **字符串 -> 数字：**
  1. Number(str): 比较严格，只要包含非数字字符就是 NaN（例如 Number("10a") -> NaN）。
  2. parseInt(str) / parseFloat(str): **最常用**。会从头解析，直到遇到非数字（例如 parseInt("10px") -> 10）。
  3. +str (一元加号): 隐式转换，效果等同于 Number()。
- **数字 -> 字符串：**
  1. String(num): 通用。
  2. num.toString(): **最常用**。注意：null 和 undefined 没有这个方法。
  3. num + "" (拼接空字符串): 隐式转换，面试时说这个显得很老练





1. **try...catch：** 最常用的，包裹可能出错的代码块。
2. **Promise.catch：** 专门处理 Promise 链式调用的报错。
3. **全局捕获：** window.onerror（了解即可）。





| 特性           | Cookie                                    | LocalStorage                     | SessionStorage                      |
| -------------- | ----------------------------------------- | -------------------------------- | ----------------------------------- |
| **存储大小**   | 很小 (4KB)                                | 大 (5MB左右)                     | 大 (5MB左右)                        |
| **生命周期**   | 可以设置过期时间，不设则关闭浏览器失效    | **永久存储**，除非手动清除       | **临时存储**，关闭标签页/窗口就没了 |
| **服务器交互** | **每次请求都会自动带给服务器** (浪费流量) | 仅保存在客户端，不参与服务器通信 | 仅保存在客户端                      |
| **用途**       | 存Token、用户登录状态                     | 存用户偏好设置、购物车数据       | 存表单临时数据                      |





#### . Vue 常用修饰符

**面试官问：** 你用过哪些修饰符？

- .prevent: 阻止默认事件（例如阻止表单提交刷新页面，等同于 event.preventDefault()）。
- .stop: 阻止冒泡（防止点击子元素触发父元素的点击事件）。
- .trim: 自动去除输入框首尾空格。
- .number: 自动把输入转为数字类型。
- .enter: 监听键盘回车键（@keyup.enter）。





- **Vue 2 经典流程：**
  1. beforeCreate / created: 实例创建。**重点：created 时数据（data）已经有了，通常在这里发 ajax 请求。**
  2. beforeMount / mounted: DOM 挂载。**重点：mounted 时页面上的 DOM 元素已经生成了，可以操作 DOM。**
  3. beforeUpdate / updated: 数据更新。
  4. beforeDestroy / destroyed: 组件销毁（清理定时器、解绑事件）。
- **Vue 3 变化：** 名字变了，created 变成了 setup()，mounted 变成了 onMounted。







你在项目里怎么封装 Axios 的？

- **核心思路（三步走）：**
  1. **创建实例：** 使用 axios.create() 设置**基地址 (baseURL)**（比如 http://api.xxx.com）和**超时时间 (timeout)**。
  2. **请求拦截器 (Request Interceptor)：**
     - 在请求发送前，统一给请求头（Header）**加上 Token**。
     - 展示 Loading 加载动画。
  3. **响应拦截器 (Response Interceptor)：**
     - **脱壳处理：** 后端返回的数据通常包了一层（如 res.data.data），在这里直接返回核心数据。
     - **统一错误处理：** 判断状态码，如果是 401（未登录）跳转登录页，如果是 500 提示服务器错误。关闭 Loading 动画。





1. **深拷贝 vs 浅拷贝：**
   - 浅拷贝只拷一层，深拷贝连里面的对象也拷一份。
   - 手写深拷贝太难？面试直接说：平时用 JSON.parse(JSON.stringify(obj)) 解决大部分问题。







- **遇到不会的：** 不要发呆。可以说：“这个细节我暂时没想起来，但在我的项目中，我是通过XXX解决类似问题的。”（往你熟悉的项目上引）。
- **关于你的项目：** 面试官极大概率会指着你的效果图问：“这个功能（比如轮播图、登录）是怎么实现的？”







# 面试可以录音，总结问题是什么，以及题型是什么





### 数组的 map vs forEach（详细对比）

面试官如果追问：“还有其他区别吗？”或者“如果我只想遍历打印一下用哪个？”

#### 1. 核心区别（口语表述）

- **forEach：** 它是“**执行者**”。它只负责把数组遍历一遍，做一些操作（比如打印日志、或者直接修改原数组的对象属性），它**不返回东西**（返回 undefined）。
- **map：** 它是“**加工厂**”。它会把原数组的每一项拿出来加工，**生成一个新的数组返回**，而且**不改变原数组**（除非你在回调里故意改引用类型的数据）。







### 第一板块：JS 运行机制（面试官判断你是否资深的试金石）

这个板块如果答得好，直接秒杀绝大多数竞争者。

#### 1. 事件循环 (Event Loop) —— **必考中的必考**

**面试官问：** “你知道 JS 的事件循环吗？宏任务和微任务的执行顺序是怎样的？”

- **标准回答逻辑：**
  1. **JS 是单线程的：** 同一时间只能做一件事。
  2. **任务分类：**
     - **同步任务：** 立即执行（比如 console.log）。
     - **异步任务：** 分为 **宏任务 (MacroTask)** 和 **微任务 (MicroTask)**。
  3. **执行顺序（口诀）：**
     - 先执行所有**同步代码**。
     - 同步代码执行完，立即清空所有的**微任务**（Promise.then, nextTick）。
     - 微任务清空后，渲染 DOM，然后去执行**一个宏任务**（setTimeout, setInterval）。
     - 循环往复。
- **追问：** setTimeout 和 Promise 谁先执行？
  - **答：** Promise.then 是微任务，setTimeout 是宏任务。所以 **Promise 先执行**。

#### 2. 防抖 (Debounce) 和 节流 (Throttle)

**面试官问：** “用户搜索框输入太快，或者窗口调整大小太频繁，怎么优化？”

- **防抖 (Debounce)：**
  - **概念：** 像是坐电梯，如果不断有人进来，电梯就一直不关门。等没人进来了，过几秒再关门走。
  - **场景：** 搜索框输入（等用户输完才发请求，防止每输一个字母就发一次）。
- **节流 (Throttle)：**
  - **概念：** 像是玩游戏技能冷却（CD），技能放了一次，必须等 3 秒才能放第二次，不管你点的多快。
  - **场景：** 滚动事件监听（onScroll）、窗口大小调整（resize），防止浏览器卡死。

------



### 第二板块：Vue 深度原理（证明你不是只会 API）

#### 1. Vue 的 nextTick 是干嘛的？

**面试官问：** “你用过 nextTick 吗？它解决了什么问题？”（这是考察你对 Vue 异步渲染的理解）

- **痛点：** 当你修改了数据 this.message = 'new'，Vue **不会立即**去更新 DOM，而是开启一个队列，等同一事件循环里的所有数据变化都结束了，再统一更新 DOM。
- **问题：** 如果你改了数据，立马想去拿 DOM 的高度（比如 div.offsetHeight），这时候 DOM 还没变，你拿到的还是旧的高度。
- **解决：** nextTick(() => { ... }) 里的代码，会在 **DOM 更新完成之后** 执行。







#### Vue 的 Diff 算法（简单版）

**面试官问：** “Vue 是怎么更新页面的？知道 Diff 算法吗？”

- **核心思路：** 虚拟 DOM (Virtual DOM)。
- **比较策略：**
  1. **只比较同级：** 不会跨层级比较，速度快。
  2. **key 的作用（必考）：**
     - **问：** v-for 循环为什么要加 :key？能用 index 做 key 吗？
     - **答：** key 是节点的唯一标识。有了 key，Vue 才能准确判断哪个节点是移动了、哪个是新加的、哪个是删除了，从而复用节点，提高性能。
     - **严谨：** 尽量**不要用 index** 做 key！如果列表顺序变了（比如删了第一项），会导致后面的节点复用错误，产生 Bug。要用数据里的唯一 id。

#### 3. ref 和 reactive 的区别（Vue 3）

**面试官问：** “Vue 3 里定义数据有两个 API，怎么选？”

- **Ref：** 一般用于定义**基本数据类型**（String, Number, Boolean）。在 JS 中操作需要加 .value。
- **Reactive：** 用于定义**对象或数组**（Object, Array）。在 JS 中操作不需要加 .value。
- **本质：** ref 如果包了一个对象，内部其实也是调用了 reactive。
- **建议：** 官方现在更推荐全用 ref，虽然写 .value 麻烦点，但不容易出错（不会丢失响应性）。

------



### 第三板块：工程化与复杂场景（工程师思维）

#### 1. 权限管理（怎么控制有些页面不让看？）

**面试官问：** “如果有一个管理后台，普通用户不能看‘用户管理’页面，你怎么做？”

- **回答思路：**
  1. **菜单控制（Sidebar）：** 登录后，后端返回该用户的“权限列表”或“菜单树”。前端根据这个列表动态渲染侧边栏菜单（没权限的菜单压根不渲染）。
  2. **路由守卫（Router Guard）：** 在 router.beforeEach 里拦截。如果用户想手动输入 URL 强行访问，判断他是否有权限，没有就跳转 403 或登录页。
  3. **按钮级别控制：** 自定义一个指令 v-permission="'add_user'"，如果没权限，直接移除这个按钮 DOM。







#### 3. 首屏加载慢怎么优化？（性能优化）

**面试官问：** “第一次打开网页太慢，白屏很久，怎么优化？”

- **路由懒加载：** 不要一次性把所有页面的 JS 都下载下来。用 () => import('./Home.vue')，访问哪个页面才加载哪个页面的代码。
- **图片懒加载：** v-lazy，进入视口才加载图片。
- **组件库按需引入：** 用 Element Plus 时，不要全量引入，用自动按需导入。
- **Gzip 压缩：** 开启 Nginx 的 Gzip，能把文件体积压缩 70% 左右。

------



### 第四板块：安全问题（Web Security）

**面试官问：** “前端有哪些常见的安全问题？”（只要记住两个缩写）

1. **XSS (跨站脚本攻击)：**
   - **原理：** 黑客在输入框里输入一段 <script>alert(1)</script>，如果前端没有转义直接渲染，这段代码就会在其他用户的浏览器里执行，偷取 Cookie。
   - **防御：** Vue/React 默认都做了转义（{{ content }} 是安全的），不要随意使用 v-html。
2. **CSRF (跨站请求伪造)：**
   - **原理：** 用户登录了 A 网站，然后点开了黑客发的 B 网站链接，B 网站利用 A 网站的 Cookie 偷偷发请求转账。
   - **防御：** Token 验证（最常用，因为 Token 不会自动带上），或者 SameSite Cookie 设置。

------



### 💡 总结与心态

既然他可能把你当工程师面，你在回答时要**自信**，多用**“专业术语”**：

- 不要说：“等一会再执行” -> 说：“**异步执行**”或者“**放入宏任务队列**”。
- 不要说：“把旧的删了换新的” -> 说：“**Diff 算法对比后更新 DOM**”。
- 不要说：“网页卡了” -> 说：“**主线程被阻塞了**”。、





#### 数组去重（一行代码搞定）

**问：** 给数组 [1, 2, 2, 3] 去重。

codeJavaScript

```
// 方法一：ES6 Set (最帅写法)
const arr = [1, 2, 2, 3];
const newArr = [...new Set(arr)]; 

// 方法二：filter (传统写法)
// 只有当当前元素的索引 等于 它第一次出现的索引时，才保留
const newArr = arr.filter((item, index) => arr.indexOf(item) === index);
```







####  拍平数组（Flat）

**问：** 把多维数组 [1, [2, [3]]] 变成 [1, 2, 3]。

codeJavaScript

```
// 方法一：ES6 flat()
const arr = [1, [2, [3]]];
// Infinity 表示不管多少层都拍平
const newArr = arr.flat(Infinity); 

// 方法二：递归 (假如面试官不让用 API)
// 思路：遍历数组，如果是数组就递归，不是就 push 进去。
```







####  获取 URL 参数

**问：** 地址栏 http://xxx.com?name=tom&age=18，怎么拿到 name？

```
// 现代浏览器 API (最推荐)
const params = new URLSearchParams(window.location.search);
const name = params.get('name'); // "tom"
```





#### Vue 的 Scoped 是怎么做到的？

**面试官问：** “为什么你在 A 组件写的样式，不会影响到 B 组件？”（即 Scoped 原理）

- **答：**
  - Vue 会给组件里的每个 DOM 元素加一个**独一无二的属性**，比如 data-v-23a9d。
  - CSS 编译时，会自动给选择器加上这个属性选择器。
  - 例如：.title 变成了 .title[data-v-23a9d]，所以只能选中当前组件的元素。





#### 怎么修改第三方组件库的样式？（样式穿透）

**面试官问：** “我想改 Element Plus 按钮的颜色，但 Scoped 挡住了，怎么办？”

- **答：** 使用**深度选择器**。
  - **Vue 2:** ::v-deep .el-button { ... } / /deep/
  - **Vue 3:** :deep(.el-button) { ... }







**工程师级回答（话术）：**

> “这个技术点我目前在项目中接触得比较少，只了解它是用来解决 [XXX问题] 的。
>
> 不过，我遇到不懂的技术通常会这样做：
>
> 1. 先查官方文档和 GitHub Issues。
> 2. 去 StackOverflow 或者掘金看类似案例。
> 3. 自己写个 Demo 验证一下。
>    **我有信心在入职后快速掌握这个知识点。**”







####  TS 的常用数据类型有哪些？

- **基础的：** string, number, boolean, null, undefined。
- **数组：** number[] 或者 Array<number>。
- **元组 (Tuple)：** 规定了长度和每个位置类型的数组，如 [string, number]。
- **枚举 (Enum)：** 用于定义一组常量，比如 enum Status { Success = 1, Fail = 0 }。
- **任意 (any)：** **（慎用）** 关闭类型检查，相当于写回了 JS。
- **void：** 通常用于函数没有返回值。







#### Interface (接口) 和 Type (类型别名) 的区别？

- **共同点：** 都可以用来定义对象、函数的形状。
- **不同点（背这两个）：**
  1. **扩展方式不同：** Interface 用 extends 继承；Type 用 & (交叉类型) 合并。
  2. **Interface 可以自动合并：** 如果你写了两个同名的 interface User {...}，TS 会自动把它们属性合并起来；Type 不行，会报错。
  3. **使用场景：** 定义**对象**或者**类**的时候通常用 interface；定义**联合类型**（如 type Status = 'success' | 'fail'）或者复杂类型时用 type。

#### 2. 什么是泛型 (Generics)？

**面试官问：** “你理解泛型吗？举个例子？”（如果你说会这个，说明你入门了）

- **通俗解释：** 泛型就是一个**“类型占位符”**。就像函数传参一样，我写代码的时候不知道要处理什么类型，等别人调用我的时候，再告诉我类型。





用 any 还是 unknown？”

- **Any：** “我不管了，放弃治疗”。TS 彻底不管，你可以对它做任何操作（很危险）。
- **Unknown：** “我暂时不知道”。TS 比较严格，如果你不先判断它是什么类型，就不准你调用它的方法（更安全）。
- **结论：** 尽量用 unknown 代替 any。





1. **Partial<T> (最常用)：** 把接口里所有属性变成**可选的**（加 ?）。

   ```
   interface User { name: string; age: number; }
   type PartialUser = Partial<User>; // { name?: string; age?: number; }
   ```

2. **Pick<T, K>：** 从接口里**挑选**几个属性出来。

3. **Omit<T, K>：** 从接口里**排除**几个属性（跟 Pick 相反）。

4. **Record<K, T>：** 定义一个对象的 Key 和 Value 的类型。







#### props 怎么定义类型？

- **写法：** 使用泛型参数。

  ```
  // <script setup lang="ts">
  const props = defineProps<{
    title: string
    count?: number // 可选
    list: Array<string>
  }>()
  ```

#### 2. ref 怎么定义类型？

- **简单的：** const count = ref(0) (TS 会自动推导为 number)。

- **复杂的（对象/数组）：**

  ```
  interface User { name: string }
  // 加上泛型 <User>
  const user = ref<User>({ name: 'Tom' })
  // 或者可能为空
  const list = ref<User[] | null>(null)
  ```

#### 3. 事件处理函数的参数类型？

**问：** “Input 输入框的 change 事件，event 对象是什么类型？”

- **答：** 一般是 Event，如果要获取 e.target.value，最好断言成 HTMLInputElement。

  ```
  const handleChange = (e: Event) => {
    // 告诉 TS，e.target 是一个输入框元素
    const val = (e.target as HTMLInputElement).value
    console.log(val)
  }
  ```





使用 TS 主要是为了保证**数据的类型安全**和**接口对接**的方便。

1. 对于**接口返回的数据**，我会专门定义 Interface，这样在写业务逻辑时，点一下就能看到后端返回了什么字段，不用反复切出去看文档。
2. 常用 **泛型** 和 **工具类型（比如 Partial）** 来复用类型定义。
3. 虽然有时候遇到复杂的类型报错会比较头疼，但我会尽量避免使用 any，而是尝试用 unknown 或者精准的类型来解决，保持代码的规范性。





window (BOM 的核心)
  ├── document (DOM 的核心) 
  ├── location (URL相关)
  ├── history (历史记录)
  ├── navigator (浏览器信息)
  └── screen (屏幕信息)







> **DOM (Document Object Model)** 是**文档对象模型**，用来操作**网页内容**（HTML/CSS）；
> **BOM (Browser Object Model)** 是**浏览器对象模型**，用来操作**浏览器窗口**（URL、历史记录、弹窗）。

------



### 2. 核心区别对比表

| 特性         | **DOM**                              | **BOM**                                         |
| ------------ | ------------------------------------ | ----------------------------------------------- |
| **全称**     | Document Object Model (文档对象模型) | Browser Object Model (浏览器对象模型)           |
| **核心对象** | document                             | window                                          |
| **管辖范围** | 网页里的 HTML 元素、CSS 样式、文本   | 浏览器窗口、地址栏、历史记录、屏幕信息          |
| **标准**     | **W3C 标准** (所有浏览器都一样)      | **非标准** (虽然现代浏览器差不多，但以前有差异) |
| **例子**     | document.getElementById('app')       | location.href, alert(), setTimeout              |

------



### 3. 详细解释与常见 API

#### (1) DOM：操作页面内容的

把整个 HTML 页面看作一棵**树（DOM Tree）**，树上的每个节点（Node）就是 HTML 标签。

- **核心作用：** 增、删、改、查 HTML 元素。
- **常用 API：**
  - **获取元素：** document.querySelector, document.getElementById
  - **修改内容：** element.innerHTML, element.innerText
  - **修改样式：** element.style.color = 'red'
  - **事件监听：** element.addEventListener('click', ...)

#### (2) BOM：与浏览器交互的

它不关心页面里写了什么 HTML，它只关心浏览器窗口本身。

- **核心作用：** 控制浏览器行为。
- **常用 API（都是 window 的属性）：**
  - **location：** 只有这个最常用。location.href (获取当前网址)、location.reload() (刷新)。
  - **history：** history.back() (后退)、history.pushState (路由跳转核心)。
  - **navigator：** navigator.userAgent (判断是手机还是电脑，或者是什么浏览器)。
  - **screen：** 获取屏幕分辨率（用的少）。
  - **定时器：** setTimeout, setInterval 其实都是 BOM 的方法。

------



### 4. 它们的关系（包含关系）

这是面试中的一个**陷阱点**或者**加分点**。

**问：DOM 和 BOM 有联系吗？**
**答：** 有。在浏览器中，**window 对象是顶层对象（老大）**。

- **DOM 其实是 BOM 的一部分**。
- document 对象其实是 window 的一个属性。
- 我们平时写 document.getElementById，完整的写法其实是 window.document.getElementById。





.finally() 是 Promise 链条的最后一步。**不管 Promise 最后是成功（Resolved）还是失败（Rejected），finally 里的回调函数都会执行。**

#### 2. 最经典的使用场景：Loading 状态管理

这是前端开发中 99% 会用到的场景。

- **场景描述：** 点击按钮发送请求 -> 页面显示“加载中...” -> 请求结束（无论成功拿到数据，还是报错网不好） -> **都需要把“加载中”关掉**。
- **如果不通过 finally：** 你得在 .then() 里写一遍 loading = false，在 .catch() 里又写一遍 loading = false。代码重复。
- **使用 finally**





### 1. Axios 响应拦截器：全局控制 (Global)

拦截器是写在 request.js 或者 api.js 这种公共文件里的。它不知道当前是哪个组件发起的请求，也不知道你组件里的变量叫什么。

- **适用场景：** 全局的、通用的 Loading。
- **最典型例子：** 浏览器顶部的进度条（如 NProgress）或者全屏的“转圈圈”遮罩层。
- **工作流程：**
  1. **请求拦截器**：开启 NProgress.start()。
  2. **响应拦截器**：关闭 NProgress.done()。

**❌ 它的局限性（为什么不能只用它）：**
拦截器**访问不到**你组件内部的变量！
比如你在 Login.vue 里有一个 isLoginBtnLoading 变量控制登录按钮转圈。
在 axios 的拦截器里，你**无法**写 isLoginBtnLoading = false，因为拦截器根本不知道这个变量的存在，也拿不到组件的 this 或 ref。



### 2. .finally()：局部控制 (Local)

.finally() 写在具体的业务组件里（比如 Login.vue, UserList.vue）。它非常清楚当前为了这个请求，哪个按钮在转圈，哪个表格在显示骨架屏。

- **适用场景：** 组件内部的、局部的 UI 状态反馈。
- **最典型例子：** 按钮变为“加载中”状态并禁用，或者表格显示 Loading 图标。
- **代码示例：**

```
// Login.vue
const handleLogin = () => {
  btnLoading.value = true; // 1. 开启按钮局部 loading
  
  api.login()
    .then(res => { ... })
    .catch(err => { ... })
    .finally(() => {
      // 2. 精确关闭这个按钮的 loading
      // 拦截器做不到这一点，因为它摸不着 btnLoading 这个变量
      btnLoading.value = false; 
    });
}
```

------



**结论：**
如果你的 Loading 是全屏遮罩，拦截器更方便。
如果你的 Loading 是某个按钮里的小转圈，或者某个卡片的局部加载，**必须用 .finally()**，拦截器帮不了你。







Promise 报错了怎么抓？try...catch 和 .catch 有什么区别？”

#### 1. 写法一：链式调用的 .catch()

这是最基础的。Promise 的错误具有**冒泡性质**，它会一直向后传递，直到被捕获。

- **基本用法：**

  ```
  api.getData()
    .then(res => {
      // 处理数据
      console.log(res.a.b); // 假设这里报错了
    })
    .catch(err => {
      // 这里能捕获到：
      // 1. 网络请求失败的错
      // 2. .then 里面代码逻辑写错的 bug (比如 res.a 是 undefined)
      console.error('统一捕获错误:', err);
    });
  ```

#### 2. 写法二：Async/Await 的 try...catch (推荐)

现在项目里大家都用 async/await，这时候就不能用 .catch 了，必须配合 try...catch。

- **基本用法：**

  ```
  async function fetchData() {
    try {
      const res = await api.getData(); // 等待请求
      console.log(res);
    } catch (err) {
      // 这里捕获错误
      console.error('请求出错了:', err);
    } finally {
      // 这里的 finally 依然有效
      console.log('结束');
    }
  }
  ```

#### 3. 进阶：如何“局部”捕获错误？（保姆级技巧）

**场景：** 一个页面要请求两个接口：getUser (用户信息) 和 getBanner (广告图)。
**要求：** 如果广告图挂了，**不要影响**用户信息的展示。

- **错误写法：** 一个大的 try...catch 包住所有。

  ```
  try {
    await getUser();
    await getBanner(); // 如果这行报错，下面全都不执行了，页面可能全白
  } catch (err) { ... }
  ```

- **正确写法（局部捕获）：**
  给可能出错但不重要的请求，单独加 catch。

  ```
  // 写法 A：给 promise 单独加 catch
  const user = await getUser();
  // 广告挂了就挂了，返回 null 兜底，不要炸坏整个函数
  const banner = await getBanner().catch(err => { 
      console.log('广告挂了'); 
      return null; 
  }); 
  
  // 渲染页面（即使 banner 是 null，用户也能看到 user）
  render(user, banner);
  ```

#### 4. 终极兜底：全局错误捕获

如果开发时忘了写 catch，导致报错红一片，怎么监控？

- **Promise 未捕获异常 (Unhandled Rejection)：**

  ```
  // 监听全局的 unhandledrejection 事件
  window.addEventListener('unhandledrejection', (event) => {
    console.error('有个 Promise 报错没人管！', event.reason);
    // 这里可以上报给监控系统（如 Sentry）
    event.preventDefault(); // 防止控制台报红
  });
  ```





####  computed 和 watch 有什么区别？怎么用？

- **Computed（计算属性）：**
  - **场景：** 一个数据依赖其他数据变动（比如：总价 = 单价 * 数量）。
  - **特点：** 有**缓存**。只要单价和数量没变，多次调用它不会重新计算。
  - **怎么写：** const total = computed(() => price.value * count.value)
- **Watch（监听器）：**
  - **场景：** 数据变了，我要**做某件事**（比如：搜索词变了 -> 发请求搜索；路由变了 -> 埋点）。
  - **特点：** 没有缓存，支持异步操作。
  - **怎么写：** watch(source, (newVal) => { console.log('变了') })





####  CSS 布局：怎么把一个东西放最右边？

（考 Flex 熟练度）

- **父元素：** display: flex;
- **方法一（最常用）：** justify-content: space-between; （一个在最左，一个在最右）。
- **方法二：** justify-content: flex-end; （都在最右）。
- **方法三：** 给子元素加 margin-left: auto; （把左边顶满，自己挤到最右边）。

#### 5. ref 和 reactive 怎么选？（Vue 3）

- **怎么用：**
  - **ref**：通吃。定义数字、字符串、布尔值、对象、数组都可以。**取值要加 .value**。
  - **reactive**：只能定义对象/数组。不用加 .value。
- **推荐回答：** “我习惯**一把梭全用 ref**，因为这样能一眼看出哪些是响应式数据，而且不容易丢失响应性。”





### 本地存储：怎么存取对象数据（比如用户信息）？

**场景：** 登录成功后，后端返回了一个 user 对象，你要把它存起来，下次打开网页还能看到。
**考点：** localStorage 只能存字符串，所以存对象必须用 JSON.stringify。

**怎么写代码：**

```
// 1. 存数据（登录成功时）
const user = { name: '曹迈', id: 101, role: 'admin' };
// ❌ 错误写法：localStorage.setItem('user', user) -> 结果变成 "[object Object]"
// ✅ 正确写法：转成 JSON 字符串
localStorage.setItem('user', JSON.stringify(user));

// 2. 取数据（在页面加载时，或者路由守卫里）
const userStr = localStorage.getItem('user');
if (userStr) {
  // ✅ 核心：拿出来是字符串，必须转回对象才能用
  const userInfo = JSON.parse(userStr);
  console.log(userInfo.name); // 输出：曹迈
}

// 3. 删数据（退出登录时）
localStorage.removeItem('user');
// 或者清空所有
localStorage.clear();
```





###  DOM 更新延迟：点击显示输入框并自动聚焦（NextTick）

**场景：** 页面上有一个按钮，点击后显示一个输入框，并且光标自动跳进去。
**考点：** Vue 的数据更新是异步的，v-if 变为 true 时，DOM 还没真正画出来，直接 focus() 会报错。

**怎么写代码：**

```
<script setup>
import { ref, nextTick } from 'vue'

const isShow = ref(false)
const inputRef = ref(null) // 绑定 DOM 元素

const showInput = async () => {
  isShow.value = true // 1. 让输入框显示
  
  // inputRef.value.focus() // ❌ 此时 DOM 还没渲染，报错！
  
  // ✅ 等待 DOM 更新完毕
  await nextTick()
  inputRef.value.focus() // 2. 现在 DOM 有了，聚焦成功
}
</script>

<template>
  <button @click="showInput">搜索</button>
  <input v-if="isShow" ref="inputRef" placeholder="请输入..." />
```





###  ES6 解构与合并：怎么处理表单数据？

**场景：** 提交表单时，后端需要的数据里包含表单数据，还需要额外加一个 token 或者 timestamp。
**考点：** 扩展运算符 ...。

**怎么写代码：**

```
const formData = {
  username: 'caomai',
  password: '123'
};

const token = 'abcd-1234';

// ✅ 需求：把 token 加进去，合并成一个新对象发给后端
const params = {
  ...formData, // 把 formData 里的属性拆开解构放进来
  token: token,
  timestamp: Date.now()
};

console.log(params);
// 输出：{ username: 'caomai', password: '123', token: 'abcd-1234', timestamp: ... }
```





1. **高亮选中：** :class="{ active: index === current }"
2. **存对象：** JSON.stringify() 和 JSON.parse()
3. **自动聚焦：** await nextTick()
4. **组件内容复用：** <slot></slot>
5. **合并数据：** const newObj = { ...oldObj, newVal }





