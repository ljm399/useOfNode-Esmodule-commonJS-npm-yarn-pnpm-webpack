# 一. webpack

## 2.1. 现代开放的整个流程

<img src="D:\Desktop\JavaScript\06_node-Esmodule-webpack-git\03_ 包管理工具\整个项目的编写过程.png" style="zoom: 200%;" />

- webpack必须在node的环境下





## 2.2. node中的path内置模块

- mac,linus,window系统其文件分隔符不同:如linus是/而window是\

- path.resolve(): 等到绝对路径
  - 记得先const path = require('path');
  - 要是没传入参数,则和__dirname这个全局属性一样的效果

- 在webpack的使用
  - webpack的配置文件中有些属性的路径必须是绝对路径
- 绝对路径:有磁盘的



## 2.3. webpack的介绍

- webpack的概念: webpack是静态的模块打包工具,为现代的JavaScript应用程序
  - 静态:可以将代码打包为最终的静态资源(部署到静态服务器)
  - 模块化:webpack默认支持各种模块化开放:ES Modeule ,commonJS, AMD等
  - 现代:为了解决前面出现的问题而出现



- webpack的安装的前提: Node/npm





- webpack的安装
  - webpack/webpack-cli
    - 必须也同时安装 webpack-cli,webpack依赖它(没安装会报错)
    - 但在第三方脚手架如vue中没有webpack-cli,而是vue-service-cli
  - 局部和全局安装
    - npm install webpack webpack-cli -g
      - npm install webpack webpack-cli -D
    - 使用局部安装更多:因为你Vue,react不同项目依赖的webpack是不同的
      - 在你下载vue,react时,它会自动给你内嵌了webpack



## 2.4. webpack可以处理的文件

- 为什么不是babel:
  - 因为bable不能自动转换
  - 而webpack在vue中内嵌后,可以自动转换
    - 比如:你在使用vue根本感受不到webpack的存在

- JavaScript的打包
  - 将ES6转为ES5
  - TypeScript => JavaScript
- Css
  - Css文件的加载和提取
  - less,Sass
- 资源文件img,font:
  - 图片img
  - 字体font
- HTML资源的处理



## 2.5. webpack的基本打包

- npx webpack



- webpack默认打包

  - ./src/index.js -> dist/main.js

  

- webpack 指定入口和出口,否则不是默认打包(上面)则报错

  - 方式一

  - npx webpack --entry ./src/main.js --output-path ./mjl

  

  - 方式二

    - 在webpack.config.js

    ```
    const path = require('path');
    
    module.exports = {
      entry: './src/main.js',
      output: {
        filename : 'mjlcode.js',
        path: path.resolve(__dirname, './mjl')
      }
    }
    ```



- webpack的配置文件

  - output的path必须是绝对路径

  

- webpack的配置文件的取名

  - webpack.config.js => wk.config.js

    - 实现过程:

    -  "scripts": {

        "bundle" : "webpack --config wk.config.js"

       },

    - npm run bundle

      - bundle(捆,包)



## 2.6. 注意

- npm init的文件包名必须没有空格,中文那些
- 创建的项目放src中---打包也是去src的index.js
- warn警告不用管,没Error就行
- 简写一个 -, 完整两个 --
  - webpack -v
  - webpack --version







# 二. webpack-loader

- loader加载器
  - webpack默认只打包js后缀文件,其他如css要配置对应loader才能加载
  - webpack把css文件,图片那些,也当做一个模块,且用import来加载这个模块
    - import "./style.css"
    - import './xx.img'
    - 和import {sum} form 'xx'区别
      - 前者要加载整个css/img模块,而后者只是引入对应方法
- ![](D:\Desktop\JavaScript\06_node-Esmodule-webpack-git\04_webpack\loader.png)



## 1.1. webpack依赖图

![](D:\Desktop\JavaScript\06_node-Esmodule-webpack-git\04_webpack\webpack打包图.png)

## 1.2. css-style

- 帮你在html文件中起<link src=....的作用

## 1.3. css-loader



## 1.4. less-loader



## 1.5. postcss-loader

- 原本使用的是autoprefixer'这个插件,但其功能就只为某个新属性如user-select加浏览器前缀从而达到解决兼容问题
- postcss-loader这个插件里面会帮你加autoprefixer同时还具有其他功能如color: #66666666本来最后两个表透明度之前是不能加的(即只能有6位),但postcss-loader会帮你处理
- 以及帮你px->rem



## webpack.config.js中

```
module: {
    rules: [
      {
        //告诉webpack匹配什么文件
        test: /\.css$/,        
        // use: [//use中多个loader是从后向前,从右向左执行
        //   {loader: "style-loader"},
        //   {loader: "css-loader"}
        // ]
        //简写一:如果loader只有一个
        // loader: 'css-loader'
        //简写二:多个
        use: [
          'style-loader', 
          'css-loader',
          // {
          //   loader: 'postcss-loader',
          //   options: {
          //     postcssOptions: {
          //       plugins: [
          //         'autoprefixer'
          //       ]
          //     }
          //   }
          // }
          'postcss-loader'
        ]
      },
      {
        test: /\.less$/,
        use: ['style-loader', 'css-loader', 'less-loader','postcss-loader']
      }
    ]
  }
```

- 由于postcss-loader在css文件和less文件都需要

  - 要是在每个里面加入下面代码太麻烦

    - ```
      {
                //   loader: 'postcss-loader',
                //   options: {
                //     postcssOptions: {
                //       plugins: [
                //         'autoprefixer'
                //       ]
                //     }
                //   }
      ```

  - solve: 提取到posstcss.config.js文件中

    - ```
      module.exports = {
        plugins: [
        	//require: 'postcss-preset-env' //require可以不加了
          'postcss-preset-env'
          // 'autoprefixer'
        ] 
      }
      ```

      



# 三. webpack打包其他资源

- 部署在服务器的文件包就是build,这个包不能再引入这个包外面的东西

### 核心思维

- 无论是什么框架或插件,无非就是把源代码打包转为HTML+CSS+JS



## 2.1. 图片,背景图片

```
//导入图片/背景图片模块
import imgUrl from "../img/xinan.jpg"//不能是import "../img/xinan.jpg"
import "../css/bg.css"

```

- 不需要安装任何loader,webpack里面内嵌了(asset)

- asset/resource

  -  // type: 'asset/resource'
  - 打包好的文件夹中有个单独文件存储该图片,并且图片有自己的网络地址
  - 弊端:相对inline,会发送多几次网络请求

- asset/inline

  -  // type: "asset/inline"
  - 图片以base64的编码存储在打包好的主文件(main.js)
  - 弊端:js文件大,下载js文件时间长,影响整个页面的加载

- asset:吸收上面两张的优缺点

  - ```
     test:/\.(png|jpe?g|svg|gif)$/,
     type: "asset",
     parser: {
        //当大于maxSize就是source,相反则inline
          dataUrlCondition: {
            maxSize: 1024 * 6//这里单位是字节
      
          }
        },
        
        //可以区分sourse方式打包图片的位置
      generator: {
          //占位符
          //name:指向原来图片的名称
          //ext:图片的扩展名
          //hash: webpack生成的hash值
          filename: 'images/[name]_[hash:8][ext]'
        }
          }
    ```

    




## 2.2. 打包js文件 - babel

### 这两个是否安装

1. npm i babel-loader -D
   - 当你使用webpack打包就用这个

2. 或npm install @babel/cli @babel-core -D

   - 当你不用webpack,而是单独用babel
     - 命令: npx babel src --out-dir dist
       - 打包src的js文件 输出到dist这个文件夹中


   - core是babel的核心,必须安装

   - cli:可以让我们在命令行中使用babel





- 然后方式一:在webpack.config.js中配置

```
{
        test: /\.js$/,
        use: {
          loader: 'babel-loader',
          //方式一
          // options: {
          //   plugins: [
          // 要下载这两个插件
          //     "@babel/plugin-transform-arrow-functions",
          //     "@babel/plugin-transform-block-scoping"
          //   ] 
          // }
          
          //方式二
          // options: {
          //   presets: ['@babel/preset-env']
          // }  

          //方式三:提取到单独文件中
        },
      }
```

- 方式二(推荐):单独文件中:babel.config.js

  - ```
    module.exports = {
      //方式一
      // plugins: [
      //   "@babel/plugin-transform-arrow-functions",//转换箭头函数
      //   "@babel/plugin-transform-block-scoping"//转换const为var
      // ]
    
      //方式二
      presets: ["@babel/preset-env"]
    }
    ```



- preset-env作用
  - npm i @babel/preset-env -D
  - 你不用再去下载方式一的两个插件,只下载这个插件就行
  - 常见的预设
    - env
    - react
    - TypeScript



## 2.3. 打包vue文件

- webpack构建项目时**不会去找全局模块**，它只会查找你项目本地
  - 所以你全局那个vue该项目没有
  - 要npm install vue@3 @vue/compiler-sfc -D
  - 同时还有让其识别vue的加载器
    - npm i vue-loader -D

- vue-loader的配置信息

  - ```
    const { VueLoaderPlugin } = require('vue-loader')
    ```

  - ![](D:\Desktop\JavaScript\06_node-Esmodule-webpack-git\04_webpack\配置信息.png)

  - ​	图中的module对象里面还有

    -  {

    ​    test: /\.vue$/,

    ​    loader: 'vue-loader'

       },

    


## 2.4. webpack解析文件路径(import .. from 'xx'或require)

- xx是绝对路径则不需要解析

- 相对路径

  - 将其认为是./,然后给其拼接上绝对路径

- 模块路径('vue')

  - 如果该模块是个文件,则先给其加上配置好的extensions数组中的后缀名(如上图)

  - 如果是文件夹,先给其加上index,然后按上面是个文件处理

  - 然后在指定的目录检索默认是node_modules

  - 可以设置别名(alias)来达到快捷方式效果(如上图)

    - ```
      // import {sum} from "../../../utils/math"
      import {sum} from "utils/math"
      console.log(sum(1, 2),"我是aaaa.js")
      ```

    - 注意在src中创建的文件记得在src/main.js中应用

      - main.js中

      - ```
        import {createApp} from 'vue'
        import hello from "./vue-demo/hellow"
        import "../src/abc/cba/nba/aaa"
        
        createApp(hello).mount('#app')
        ```

      - html中

        - ```
            <div id="app"></div>
            <hr>
            <script src="./build/index.js"></script>
          ```

​		



# 四.webpack的插件

## 3.1. 认识Plugin

- 和loader区别
  - plugin可以作用全局
    - 比如打包优化,插入变量,贯穿整个生命周期

  - 而loader只能是特定的模块类型转换
  - 具体区别:自己学到后面等广度够了,回来看便懂了



- webpack.config.js中

```
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
//这个插件webpack5中已经内置了，不需要手动安装
const { DefinePlugin } = require('webpack')

....
 plugins: [
    new VueLoaderPlugin(),
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title: '电商项目',
      //自己定义模板
      template: './index.html',
    }),
    new DefinePlugin({
      //注意这里所有值(不单只BASE_URL)的值是eval包裹的字符串,所有要用单引号包裹,不然会当做个变量处理
      BASE_URL: "'../'",
      mjlcode: "'123444code'",
      iam: "'mjlcode'"
    })
  ]
```




## 3.2. CleanWebpackPlugin(如上图)

- 可以清除之前打包的内容,然后替换为新的

- npm i cleanWebpackPlugin -D



- 替代方法(推荐)--clean属性

  - ```
    module.exports = {
      mode: 'development',
      entry: './src/main.js',
      output: {
        filename : 'index.js',
        path: path.resolve(__dirname, './build'),
        clean: true,
      },
    ```

  - clean:true(不用安装不用引入,内置属性效果和cleanWebpackPlugin)





## 3.3. HtmlWebpackPlugin(如上图)

- 打包后文件会生成个html文件,这样就不用自己在搞个html文件
- 这个html直接可以浏览器加载,不用格式化或其他装换
- npm i  HtmlWebpackPlugin -D
- 同时可以自定义模板

  - ```
     new HtmlWebpackPlugin({
          title: '电商项目',
          //自己定义模板
          template: './index.html',
      }),
    ```

  - 然后再html中引用

    - title><%= htmlWebpackPlugin.options.title %></title




## 3.4. DefinePugin(如上图)

- webpack内置,不用安装,但要引入,上面俩个插件既要安装又要引入

  - const { DefinePlugin } = require('webpack')

  

- 上图new DefinePlugin中传入的参数如上图的mjlcode,BASE_URL

  - 其他地方如下面代码跨文件访问
    - 如html
      -  link rel="icon" href="<%= BASE_URL %>favicon.ico"
      -  图中配置是"'./'"





## 3.5. model配置

- 在webpack.config.js中

- development
- production
- 设置好model配置,webpack,则相当于设置好了许多属性的默认值
  - ![](D:\Desktop\JavaScript\06_node-Esmodule-webpack-git\04_webpack\默认配置.png)

- 其他文件访问是什么工作环境的操作
  - clg(process.env.NODE_ENV)//development或production



## 3.6 更多options和插件看官网

https://webpack.js.org/guides/output-management/



# 五.webpack-dev-server

## 4.1. 使用webpack-dev-server

- 作用

  1. 自动编译-----------npx webpack
     - 但不会生成包,打包后内存中,然后给你搭建个本地服务器

  2. 响应式即自动刷新浏览器------------live serve



- npm i webpack-dev-server -D 
- 在config中的配置

```
 mode : "development"
 devServer: {
    hot: true,//默认就是开的
    port: 5000,
    open: true,
    host: "127.0.0.1"
  },
```

- 注意模式是development,因为这里相当于你在调试,看有什么问题

  - 对比开发模式,资源部署到服务器就行了,不需要什么html文件

- package.json

  - ```
    "scripts": {
        "build": "webpack --config wk.config.js",
        "serve": "webpack serve --config wk.config.js"
      },
    ```





## 4.2. HMR热模块替换

- hot: true ---默认是开启

- 然后再main.js,选择要开启HMR的模块,这样这个模块更新就不会让整个页面都更新

  - ```
    import "./utils/HMR"
    if(module.hot) {
      module.hot.accept("./utils/HMR.js", ()=> {
        console.log("HMR更新了模块内容")
      })
    }
    ```


- 注意src里面的main.js,这个模块不能引入HMR.js的方法,不然页面还是会刷新
  - import {sum} from "./utils/HMR.js"错
  - import "./utils/HMR"对



## 4.3. devServer配置

- host
  - 0.0.0.0 则该网段的设备只有端口对了,都可以访问
  - 127.0.0.1 发出去自己接受
- port
  - 自定义端口号
- open
  - 默认false
  - true则npm run serve自动打开浏览器
- compress
  - npm run serve
  - 则浏览器拿到的数据是压缩过的
    - content-Encoding:br / gzip --------br比gzip压缩率更高



# 六. webpack开放和生产分离

### 开发和生成区别

- 更具体,等广度够在深度
- ![](D:\Desktop\JavaScript\06_node-Esmodule-webpack-git\04_webpack\开发和生成区别.png)





- 先npm install webpack-merge -D
- 然后dev或pro文件中引入
  - const { merge } = require('webpack-merge');

- webpack.config.js变为

  - webpack.common.config.js

  - webpack.dev.config.js

  - webpack.pro.config.js


- 为什么里面的导出都是CommonJS,因为你是node run build/node run serve 
  - 都是node的环境下运行,而node只运行commonJS ------ 这里不是webpack打包了
  - 可以运行ESModule模块,但要做额外配置

