#### clientHeight (可视高度)

- **公式：** 内容高度 + padding
- **不包含：** border、margin、滚动条。
- **含义：** 用户眼睛一眼能看到的区域内部的高度（不含边框）。
- **场景：** 计算可视区域大小。

#### 2. offsetHeight (占位高度)

- **公式：** 内容高度 + padding + border + 滚动条
- **不包含：** margin。
- **含义：** 这个元素在页面上**实际占据**了多大的地盘（含边框）。
- **场景：** 获取元素在页面中的物理尺寸（比如要做动画或者定位时）。
- **记忆：** Offset 意思是“偏移/位置”，算位置肯定要把边框也算上。

#### 3. scrollHeight (实际内容高度)

- **公式：** 实际内容的高度 + padding
- **含义：** 包含了**因为溢出而被隐藏**的那部分内容。如果内容没有溢出，它等于 clientHeight。
- **场景：** 判断内容是不是到底了



### 三大 Top 对比（位置相关）

#### 1. clientTop

- **含义：** 其实就是 **上边框的宽度** (border-top-width)。
- **用处：** 极少用到，除非你在做非常精确的 canvas 绘图。

#### 2. offsetTop

- **含义：** 当前元素顶部距离**最近的定位父级**（positioned parent）顶部的距离。
  - 如果父级都没定位（position: static），那就一直找到 body。
- **用处：** 计算元素距离页面顶部的距离（做吸顶导航时常用）。

#### 3. scrollTop (卷去的高度)

- **含义：** 滚动条向下滚动的距离（即：**内容顶部**被隐藏了多少）。
- **特性：** **它是可读写的！** element.scrollTop = 0 可以让它回到顶部。





###  “如何判断用户滚动到底部了？”（从而触发加载更多数据）

**公式（死背）：**

codeJavaScript

```
// 卷去的高度 + 可视区域的高度 >= 实际内容的高度
// 为了容错，通常会减去一个阈值（比如 50px），提前加载
if (element.scrollTop + element.clientHeight >= element.scrollHeight - 50) {
    console.log("触底了，加载下一页！");
}
```






这部分知识点是前端面试中**极其容易混淆**，但又**必考**的细节。特别是做“懒加载”、“无限滚动”、“吸顶效果”时，必须对这几个属性烂熟于心。

为了帮你彻底分清楚，我把它们分为三组：**client（可视）**、**offset（占位）**、**scroll（滚动）**。

请记住这个核心逻辑：**都是只读属性（除了 scrollTop）**。

------



### 一、 三大高度对比（核心必考）

假设一个 div 有内容、padding、border 和 margin。

#### 1. clientHeight (可视高度)

- **公式：** 内容高度 + padding
- **不包含：** border、margin、滚动条。
- **含义：** 用户眼睛一眼能看到的区域内部的高度（不含边框）。
- **场景：** 计算可视区域大小。

#### 2. offsetHeight (占位高度)

- **公式：** 内容高度 + padding + border + 滚动条
- **不包含：** margin。
- **含义：** 这个元素在页面上**实际占据**了多大的地盘（含边框）。
- **场景：** 获取元素在页面中的物理尺寸（比如要做动画或者定位时）。
- **记忆：** Offset 意思是“偏移/位置”，算位置肯定要把边框也算上。

#### 3. scrollHeight (实际内容高度)

- **公式：** 实际内容的高度 + padding
- **含义：** 包含了**因为溢出而被隐藏**的那部分内容。如果内容没有溢出，它等于 clientHeight。
- **场景：** 判断内容是不是到底了。

------



### 二、 三大 Top 对比（位置相关）

#### 1. clientTop

- **含义：** 其实就是 **上边框的宽度** (border-top-width)。
- **用处：** 极少用到，除非你在做非常精确的 canvas 绘图。

#### 2. offsetTop

- **含义：** 当前元素顶部距离**最近的定位父级**（positioned parent）顶部的距离。
  - 如果父级都没定位（position: static），那就一直找到 body。
- **用处：** 计算元素距离页面顶部的距离（做吸顶导航时常用）。

#### 3. scrollTop (卷去的高度)

- **含义：** 滚动条向下滚动的距离（即：**内容顶部**被隐藏了多少）。
- **特性：** **它是可读写的！** element.scrollTop = 0 可以让它回到顶部。
- **场景：** 这里的核心公式面试必问（见下文）。

------



### 三、 总结图解表（面试背这个）

| 属性             | 包含内容                   | 包含 Border? | 包含滚动条? | 作用                   |
| ---------------- | -------------------------- | ------------ | ----------- | ---------------------- |
| **clientHeight** | Content + Padding          | ❌ NO         | ❌ NO        | 盒子内部可视区域大小   |
| **offsetHeight** | Content + Padding + Border | ✅ YES        | ✅ YES       | 盒子整体占位大小       |
| **scrollHeight** | 真实内容 + Padding         | ❌ NO         | ❌ NO        | 内容的总高度（含溢出） |

------



### 四、 面试高频实战题：触底加载（无限滚动）

**面试官问：** “如何判断用户滚动到底部了？”（从而触发加载更多数据）

**公式（死背）：**

codeJavaScript



```
// 卷去的高度 + 可视区域的高度 >= 实际内容的高度
// 为了容错，通常会减去一个阈值（比如 50px），提前加载
if (element.scrollTop + element.clientHeight >= element.scrollHeight - 50) {
    console.log("触底了，加载下一页！");
}
```

- scrollTop: 滚了多少。
- clientHeight: 眼睛能看多少。
- scrollHeight: 总共有多少。
- **理解：** 我滚出去的 + 我现在看到的 = 总共的，那就是到底了。

------





除了元素的属性，面试官有时候会问浏览器窗口的大小：

1. **获取浏览器窗口可视高度：**

   - window.innerHeight (现代浏览器推荐，包含滚动条)
   - document.documentElement.clientHeight (HTML文档的高度)

2. **获取页面滚动的距离（兼容性写法）：**

   ```
   const scrollTop = window.pageYOffset 
                     || document.documentElement.scrollTop 
                     || document.body.scrollTop;
   ```

3. **神器：getBoundingClientRect()**
   如果面试官问：“怎么最方便地获取一个元素距离视口（浏览器左上角）的坐标？”

   - **答：** 使用 dom.getBoundingClientRect()。
   - 它返回一个对象：{ top, left, bottom, right, width, height }。
   - 这里的 top 是相对于**当前视口**的，而不是相对于页面顶部的（随滚动变化）。





#### 规则一：size 必须跟在 position 后面，并用 / 分隔

如果你想写 background-size，就必须先写 background-position。

- **❌ 错误：** background: center cover; (浏览器看不懂哪个是位置，哪个是尺寸)
- **✅ 正确：** background: center / cover; (斜杠前是位置，后是尺寸)

#### 规则二：origin 和 clip 的顺序

这两个属性的值很像（都是 border-box, padding-box, content-box）。

- 如果只写一个值：同时应用给 origin 和 clip。
- 如果写两个值：**第一个是 origin，第二个是 clip**。

### 3. 实战中最常用的写法（背这个代码）

面试或工作中，最常见的“全套”写法是这样的：

codeCSS

```
/* 顺序：颜色 图片 平铺 位置/尺寸 固定 */
background: #f00 url('img.png') no-repeat center center / cover fixed;
```





### lodash

```
// 1. 安装 lodash
// npm install lodash

// 2. 引入
import _ from 'lodash';

// 3. 使用防抖 (搜索)
const search = _.debounce((val) => {
```





 ECharts 的“四步走”：

1. **准备容器：** HTML 里要有一个有宽高的 div。
2. **初始化：** echarts.init(dom节点)。
3. **写配置项 (option)：** 这是最关键的，包含数据和样式。
4. **渲染：** myChart.setOption(option)。



#### option 的七大

面试官问：“配置项里有哪些主要属性？”

- **title**: 标题。
- **tooltip**: **提示框**（鼠标悬停时显示的数据）。
- **legend**: **图例**（点击可以筛选显示/隐藏某组数据）。
- **xAxis / yAxis**: X轴和Y轴（折线图、柱状图必须有）。
- **series**: **系列列表**（这是**最重要**的，真正的数据在这里，指定图表类型 type: 'line' 或 'bar'）。
- **grid**: 网格（控制图表在容器里的边距）。
- **color**: 调色盘。





**浏览器窗口大小变了，图表变形了怎么办？（自适应）**

- **答：** 需要监听 window 的 resize 事件，调用 ECharts 实例的 .resize() 方法。

```
// Vue 写法
onMounted(() => {
  const chart = echarts.init(document.getElementById('main'));
  chart.setOption({ ... });

  // ✅ 核心代码
  window.addEventListener('resize', () => {
    chart.resize();
  });
});
```





- **GET** 用 **Params**。
- **POST** 用 **Body -> raw -> JSON**。
- **Token** 放 **Headers -> Authorization**。





### Grid 布局（上帝视角）

**核心场景：** 二维布局（画格子），搞定复杂的页面骨架、九宫格。

#### 场景 1：等分列（三列布局）

不管屏幕多宽，永远雷打不动的三列。

```
.grid-box {
  display: grid;
  /* 核心：1fr 代表一份。这里就是 1:1:1 */
  /* repeat(3, 1fr) 等同于 1fr 1fr 1fr */
  grid-template-columns: repeat(3, 1fr); 
  gap: 20px; /* 格子之间的间距（不用写 margin 了） */
}
```

#### 场景 2：一大两小（非对称布局）

左边占 2 份，中间占 1 份，右边固定 100px。

```
.grid-box {
  display: grid;
  grid-template-columns: 2fr 1fr 100px;
}
```





###  路由/页面懒加载的核心原理（必答）

**一句话总结：** 路由懒加载 = **ES6 动态导入 (import())** + **Webpack/Vite 代码分割 (Code Splitting)** + **JSONP/网络请求**。

#### 1. 编译阶段：代码分割 (Code Splitting)

- **发生了什么：** 当 Webpack 或 Vite 在构建打包时，扫描到 import('./Home.vue') 这种语法时，它知道这个文件**不能**打进那个巨大的 main.js (或者 app.js) 主包里。
- **结果：** 它会把 Home.vue 及其依赖，**单独切割**出来，生成一个独立的文件（比如 src_views_Home_vue.js 或 chunk-1a2b.js）。

#### 2. 运行阶段：动态导入 (Dynamic Import)

- **语法层面：** import() 是 ES6 的一个特性，它返回一个 **Promise**。
- **逻辑层面：** 当用户点击菜单切换到 /home 路由时，Vue Router 发现这个组件是一个函数（Promise），就会开始执行加载逻辑。

#### 3. 网络交互：JSONP / Script 标签插入 (最底层的操作)

- **怎么拿代码？** 浏览器底层并没有“懒加载”这个 API。

- **Webpack 的做法：** 当你需要这个页面时，Webpack 运行时代码会动态创建一个 <script> 标签，src 指向刚才切出来的那个 chunk-xx.js，然后把它塞到 document.head 里。

  ```
  // 伪代码，模拟底层原理
  const script = document.createElement('script');
  script.src = 'http://cdn.com/chunk-home.js';
  document.body.appendChild(script);
  ```

- **执行：** 脚本下载完成后，会自动执行，把组件对象注册回去，Promise 状态变为 resolve，Vue 拿到组件，开始渲染页面。





####  组件懒加载 (Async Components)

- **原理：** 和路由懒加载**一模一样**。
- **场景：** 比如一个弹窗 (Dialog) 很重，或者一个复杂的图表 (ECharts)。只有当用户点击“打开”按钮，或者 v-if="true" 的时候，才去加载这个组件的代码。
- **代码：** defineAsyncComponent(() => import('./MyChart.vue'))。

###### 深度原理

- **编译时（Webpack/Vite 做了什么）：**
  - 构建工具扫描到 import('...') 语法，它意识到这是一个**代码分割点 (Split Point)**。
  - 它不会把 Home.vue 的代码打包进 index.js，而是单独生成一个文件，例如 assets/Home.12345.js。
- **运行时（浏览器做了什么）：**
  - () => import(...) 本质上是一个返回 **Promise** 的函数。
  - 当 Vue Router 匹配到 / 路径时，它执行这个函数。
  - 浏览器发起一个 **JSONP 请求**（或者是动态插入 <script src="assets/Home.12345.js"> 标签）。
  - 下载完毕后，JS 执行，Promise 状态变为 resolved，Vue 拿到组件对象，开始挂载渲染。



#### 2. 图片懒加载 (Image Lazy Loading) —— **原理完全不同！**

这是最容易混淆的。路由懒加载是分拆 JS 代码，图片懒加载是延迟加载 <img> 资源。

- **原理 A (老方案)：**
  - 把图片地址存在 data-src 属性上，src 留空。
  - 监听滚动事件 (window.onscroll + 节流)。
  - 计算图片位置：img.getBoundingClientRect().top < window.innerHeight (图片是不是出现在视口里了？)。
  - 如果出现了，就把 data-src 赋值给 src，浏览器开始下载图片。
- **原理 B (新方案 - 必答)：**
  - 使用 **IntersectionObserver** API。这是一个浏览器原生 API，专门用来监听“元素是不是进入了可视区域”，性能比监听滚动好得多。

#### 3. 资源预加载 (Prefetch / Preload) —— 懒加载的“反面”

面试官可能会问：“懒加载虽然好，但用户点击时才下载，会有几百毫秒的白屏，怎么优化？”

- **原理：** 利用浏览器空闲时间，偷偷把还没用到的文件先下下来。
- **Prefetch：** <link rel="prefetch" href="chunk-about.js">。告诉浏览器：“这文件将来可能要用，你等**网络空闲**的时候帮我下载好存在缓存里。”等用户真的点进去时，直接从缓存取，速度极快。





1. **路由懒加载** = 打包切片 (Webpack) + 按需请求 (Script标签) + Promise。
2. **图片懒加载** = IntersectionObserver (观察者) + 替换 src。
3. **优化体验** = Prefetch (空闲时偷偷下)。







**IntersectionObserver**。

#### 1. 核心原理

**IntersectionObserver (交叉观察器)** 是浏览器原生提供的 API，它可以**自动监听**一个元素是否进入了视口（Viewport），且性能极高，不会阻塞主线程。

#### 2. 手写 Vue 指令实现 v-lazy

面试时写出这个指令，直接杀爆全场。

```
// 1. 定义一个全局指令 v-lazy
const lazyPlugin = {
  install(app) {
    app.directive('lazy', {
      // 指令挂载到元素上时触发
      mounted(el, binding) {
        // binding.value 就是你传进来的图片地址
        // el 是原本的 img 标签        
        // 1. 创建观察器
        const observer = new IntersectionObserver((entries) => {
          // entries 是所有被观察元素的数组（因为可以同时观察多个）
          const entry = entries[0]          
          // 2. 判断是否进入视口 (isIntersecting 为 true 代表进来了)
          if (entry.isIntersecting) {            
            // 3. 核心动作：把真实的图片地址赋给 src
            el.src = binding.value            
            // 4. 停止观察（重要！）：
            // 图片加载出来后，就没必要继续盯着它了，节省资源
            observer.unobserve(el)
          }
        })
        
        // 5. 开启观察
        observer.observe(el)
      }
    })
  }
}

export default lazyPlugin
```

#### 3. 在组件里怎么用？

```
<template>
  <!-- 
    一开始 src 可以放一个很小的 loading 占位图 
    v-lazy 放真实的大图地址
  -->
  <img src="./assets/loading.gif" v-lazy="'https://big-image.jpg'" />
  <img src="./assets/loading.gif" v-lazy="'https://big-image-2.jpg'" />
</template>
```

#### 4. 深度细节（防止追问）

- **问：为什么不用 window.onscroll？**
  - **答：** scroll 事件触发频率极高（滑动一下触发几十次），必须配合**防抖/节流**，而且需要手动计算 scrollTop 和 offsetTop，会强制浏览器**重排 (Reflow)**，性能很差。而 IntersectionObserver 是浏览器底层优化的，异步执行，性能最好。
- **问：如果网络很慢，图片加载失败怎么办？**
  - **答：** 可以在 el.src = binding.value 之后监听 el.onerror 事件，如果加载失败，把 src 换成一张“加载失败”的兜底图。



###  data-src 是什么？

```vue
<template>
  <div class="container">
    <div class="item" v-for="(url, index) in imageList" :key="index">
      <!-- 
        关键点：
        1. :ref="(el) => imgRefs.push(el)" -> 把 DOM 存到 imgRefs 数组里
        2. src -> 放占位图（loading图）
        3. :data-src -> 放真实图片的地址
       -->
      <img 
        :ref="(el) => { if(el) imgRefs.push(el) }" 
        src="https://via.placeholder.com/600x400?text=Loading..." 
        :data-src="url"
        alt="懒加载图片"
        class="lazy-img"
      />
    </div>
```

这是这个写法的核心，你要这样解释：

1. **不直接写 src**：如果直接写 src="真实地址"，浏览器一解析 HTML 就会立马去下载图片，哪怕图片在屏幕最底下，这样就达不到懒加载的目的了。
2. **利用 data-src**：这是一个 HTML5 的自定义属性（你可以叫 data-abc，但规范叫 data- 开头）。我把真实地址先“暂存”在这里，浏览器不会去下载它。
3. **JS 替换**：当 IntersectionObserver 告诉我图片出现了，我再把 dataset.src 赋值给 src，这时候浏览器才真正发起网络请求。



，我们通常**直接用现成的库**，而不是每次都手写 IntersectionObserver。

在 Vue 3 生态中，最常用、口碑最好的库是 **vue3-lazyload**（注意名字，是专门为 Vue 3 写的）。

以下是**保姆级**的使用教程，面试或者做项目直接用这一套：

------



### 1. 下载安装

打开终端，运行命令：

```
npm install vue3-lazyload
# 或者用 yarn
yarn add vue3-lazyload
```

------



### 2. 全局注册 (main.ts/main.js)

这一步是为了告诉 Vue：“我要用这个插件，并且设置一下**默认的加载图**和**报错图**”。

```
import { createApp } from 'vue'
import App from './App.vue'
// 1. 引入插件
import VueLazyLoad from 'vue3-lazyload'

// 准备两张本地图片（放在 assets 文件夹下）
import loadingImg from './assets/loading.gif'
import errorImg from './assets/error.png'

const app = createApp(App)

// 2. 注册并配置
app.use(VueLazyLoad, {
  // 加载中显示的图（占位图）
  loading: loadingImg,
  // 加载失败显示的图（兜底图）
  error: errorImg,
  // 可是区域的观察比例（默认1.0，想提前一点加载可以设为 1.2 等）
  // threshold: 0.1 
})

app.mount('#app')
```

------



### 3. 页面中使用 (超级简单)

现在你不用自己写 data-src 了，直接把 :src 换成 **v-lazy** 指令即可。

```
<template>
  <div class="container">
    <!-- 
      原来：<img :src="item.url" /> 
      现在：<img v-lazy="item.url" />
      
      效果：
      1. 一开始显示 main.js 里配置的 loading.gif
      2. 滚动到了，自动替换成 item.url
      3. 如果 item.url 挂了，自动显示 error.png
    -->
    <img v-lazy="url" class="my-img" />
    
    <!-- 也可以单独针对某张图设置 loading/error，覆盖全局配置 -->
    <img v-lazy="{ src: url, loading: 'other-loading.gif', error: 'other-error.png' }" />
  </div>
</template>

<script setup>
const url = 'https://via.placeholder.com/600x400'
</script>
```





#### 事件模型

- **三个阶段**：捕获阶段 (Capture) -> 目标阶段 (Target) -> 冒泡阶段 (Bubbling)。
- **事件委托**：
  - 原理：利用**事件冒泡**，把子元素的事件绑定在父元素上。
  - 优点：省内存（不用给每个 li 绑事件）、支持动态新增的元素。
  - 区分：e.target (实际点的谁) vs e.currentTarget (事件绑在谁身上)。

#### 2. 阻止行为

- e.stopPropagation()：阻止冒泡。
- e.preventDefault()：阻止默认行为（如链接跳转、表单提交）。

------



### 第三板块：浏览器原理（高分项）

#### 1. 渲染原理（从 URL 到页面显示）

1. 解析 HTML -> 生成 DOM 树。
2. 解析 CSS -> 生成 CSSOM 树。
3. DOM + CSSOM -> 生成 **Render Tree (渲染树)**。
4. **回流 (Reflow/Layout)**：计算元素的位置、大小。
5. **重绘 (Repaint)**：绘制颜色、背景、阴影。
   - *考点：回流必导致重绘，重绘不一定导致回流。*

#### 2. 跨域 (Cross-Origin)

- **同源策略**：协议、域名、端口必须一致。
- **解决方案**：
  - **CORS** (最常用)：后端设置 Access-Control-Allow-Origin。
  - **JSONP** (老技术)：利用 <script> 标签不受同源策略限制（只支持 GET）。
  - **Proxy** (开发环境)：Webpack/Vite 代理。

#### 3. 存储

- **Cookie**：4KB，每次请求都会带给服务器（浪费流量）。
- **LocalStorage**：5MB，永久存储。
- **SessionStorage**：5MB，页面关闭就没了。



### 第四板块：CSS 原生（布局与机制）

#### 1. 盒模型

- content-box (标准)：width = 内容。
- border-box (怪异/IE)：width = 内容 + padding + border (**推荐**)。

#### 2. BFC (块级格式化上下文)

- **是什么**：一个独立的渲染区域，内部元素怎么折腾不影响外面。
- **怎么触发**：overflow: hidden / display: flex / position: absolute / float。
- **解决了什么**：
  1. 清除浮动（父元素高度塌陷）。
  2. 防止 Margin 重叠（外边距合并）。

#### 3. 居中与布局

- **Flex**：justify-content: center; align-items: center;
- **Absolute**：top: 50%; left: 50%; transform: translate(-50%, -50%);





- **< script async>**（异步）：
  - **下载**：不阻塞 HTML 解析（异步下载）。
  - **执行**：下载完**立马执行**（打断 HTML 解析）。
  - **顺序**：谁先下完谁先跑，**不保证顺序**（容易报错）。
  - *场景：百度统计代码、广告代码（不依赖其他 JS）。*
- **< script defer>**（推迟）：**（推荐）**
  - **下载**：不阻塞 HTML 解析。
  - **执行**：等到 **HTML 解析完了**（DOMContentLoaded 之前）才执行。
  - **顺序**：**严格按照书写顺序执行**。
  - *场景：业务代码，依赖 jQuery 或其他库的代码。*



### 二、 JS 运行机制：宏任务、微任务与 UI 渲染（魔鬼细节）

你可能背过 Event Loop，但原生面试会问得更细：**UI 渲染插在哪里？**

1. **执行顺序：**
   - 同步代码执行完。
   - 清空所有 **微任务 (Microtask)** (Promise.then, MutationObserver)。
   - **尝试进行 UI 渲染** (Update Rendering)。
   - 执行一个 **宏任务 (Macrotask)** (setTimeout, setInterval, MessageChannel)。
   - ...循环。
2. **必问坑点：requestAnimationFrame (rAF)**
   - **问：** 它属于宏任务还是微任务？
   - **答：** 都不属于。它是**渲染帧**的一部分。它会在**浏览器下一次重绘之前**执行。通常用来做高性能动画，比 setTimeout 准，因为它跟着屏幕刷新率走（60Hz）。



### 三、 垃圾回收 (GC) 与 内存泄漏（原生必问）

框架帮我们做了很多，但原生必须懂内存。

1. **垃圾回收算法**：
   - **引用计数**（老）：循环引用会由内存泄漏（IE6/7）。
   - **标记清除**（现代）：从根节点（Window）往下找，**“触达不到”**的对象就回收。
2. **常见的内存泄漏场景（避坑）：**
   - **意外的全局变量**：函数里没写 var/let/const，直接 a = 1，变成了 window.a，永远不回收。
   - **被遗忘的定时器**：setInterval 没关 (clearInterval)。
   - **闭包**：引用的变量不会被释放。





1. **XMLHttpRequest (XHR)**：
   - 老牌，语法复杂（回调地狱）。
   - 支持**监听上传进度** (onprogress)。
   - 支持**原生取消** (abort())。
2. **Fetch**：
   - 基于 Promise，语法简洁。
   - **坑 1（最重要）：** **HTTP 报错（404, 500）它不会 Reject！** 只有网络断了它才 Reject。你需要手动判断 if (!res.ok) throw Error()。
   - **坑 2：** 默认不带 Cookie，要加 credentials: 'include'。
   - **坑 3：** 以前不能取消，现在要配合 AbortController 才能取消。





1. **Map vs Object**：
   - Object 的 Key 只能是字符串/Symbol；Map 的 Key 可以是**任何类型**（对象、函数都行）。
   - Map 也是有序的。
2. **WeakMap**：
   - Key 只能是对象。
   - **弱引用**：如果 Key 对象没有其他引用了，垃圾回收会直接带走，不会内存泄漏。（常用于存 DOM 节点的私有数据）。





#### 隐式类型转换（大坑）

**问：** [] == ![] 是 true 还是 false？为什么？
**答：** **True**。

- **解析步骤（背逻辑）：**
  1. ![] 优先级高：空数组转布尔是 true，取反是 **false**。
  2. 现在变成 [] == false。
  3. 遇到 ==，两边都要转数字。
  4. false 转数字是 **0**。
  5. [] 转数字（调用 valueOf -> toString）是空字符串 ""，再转数字是 **0**。
  6. **0 == 0**，所以是 true。





### 性能优化：CSS 硬件加速（GPU）

**问：** “为什么做动画推荐用 transform 而不是 left/top？”

- **回流与重绘的角度：**
  - 修改 left/top：会触发 **Layout (回流)** -> Paint (重绘) -> Composite (合成)。浏览器要重新计算布局，很累。
  - 修改 transform/opacity：**不会触发回流和重绘**，只触发 **Composite (合成)**。
- **硬件加速原理：**
  - 浏览器会把应用了 transform 的元素单独提到一个**图层 (Layer)**。
  - 这个图层的变换操作直接交给 **GPU** 去处理，不占用 CPU 主线程。
- **怎么强行开启 GPU 加速？**
  - will-change: transform;
  - 或者老土方：transform: translateZ(0);





1. **Object.defineProperty (Vue 2)：**
   - **拦截的是属性：** 必须遍历对象每个属性进行拦截。
   - **缺陷：**
     - **无法监听新增/删除属性**（所以 Vue2 需要 $set）。
     - **无法监听数组下标的变化**（所以 Vue2 重写了数组方法）。
2. **Proxy (Vue 3)：**
   - **拦截的是整个对象：** 不管你操作哪个属性，我一把梭全拦住。
   - **优势：**
     - 能监听到新增、删除。
     - 能监听到数组变化。
     - 懒代理（性能更好，访问到深层属性时才去代理，而不是一开始就递归全转了）。





#### 展开运算符 (Spread Operator ...)

- **场景 1：** 合并数组/对象。

  ```
  const arr1 = [1, 2];
  const arr2 = [...arr1, 3, 4]; // [1, 2, 3, 4]
  const objNew = { ...objOld, status: 'active' };
  ```

- **场景 2：** 函数传参（剩余参数 Rest）。

  ```
  function sum(...args) { // args 变成了数组 [1, 2, 3]
    // ...
  }
  ```





#### Map 和 Set

- **Set：** 成员**唯一**的集合。
  - *实战必用：* 数组去重 [...new Set(arr)]。
- **Map：** 键值对集合。
  - *区别：* Object 的键只能是字符串/Symbol，Map 的键可以是**任何类型**（包括对象）。

#### 2. Symbol

- **作用：** 独一无二的值。通常用于定义对象的私有属性，防止属性名冲突。





#### 可选链 (?.) 和 空值合并 (??)

**场景：** 后端返回的数据层级很深，你不确定中间有没有 null。

- **可选链 ?.**：防止报错。

  ```
  // 以前：if (res && res.data && res.data.user) ...
  // 现在：
  const name = res?.data?.user?.name; 
  // 如果中间断了，name 就是 undefined，不会报错崩页面。
  ```

- **空值合并 ??**：比 || 更安全。

  ```
  const count = 0;
  
  // 用 || 的坑：0 被当成 false，结果变成了 10
  const a = count || 10; // 10 (错误)
  
  // 用 ?? 的好：只有 null 和 undefined 才会用默认值，0 是有效值
  const b = count ?? 10; // 0 (正确)
  ```







#### for...of vs for...in

**问：** “遍历数组用哪个？”

- **for...in**：遍历的是 **Key (索引)**。
  - 缺点：会遍历原型链上的属性，顺序不一定保证。**不推荐遍历数组**，适合遍历对象。
- **for...of**：遍历的是 **Value (值)**。
  - **推荐**用于数组、Map、Set、字符串。支持 break 和 continue（forEach 不支持）





#### “把数组 ['a', 'b', 'a'] 转换成对象 {a: 2, b: 1}？”

```
const arr = ['a', 'b', 'a'];
const count = arr.reduce((acc, cur) => {
  // 如果 acc 里有这个 key，就 +1，否则设为 1
  acc[cur] = (acc[cur] || 0) + 1;
  return acc;
}, {});
```

- 如果是第一次遇到 'a'：acc['a'] 是 undefined（假）。undefined || 0 结果取 **0**。最后 0 + 1 = 1。
- 如果是第二次遇到 'a'：acc['a'] 是 1（真）。1 || 0 结果取 **1**。最后 1 + 1 = 2。

reduce 的机制是：**这一次回调函数的返回值，会直接变成下一次循环的 acc。**

- 如果你不写 return acc，函数默认返回 undefined。
- 到了下一轮，acc 就变成 undefined 了，再执行 acc[cur] 直接报错 crash！





**小程序前端**、**你的后端服务器**、**微信接口服务**。

```
1. 前端 (UniApp)      ---->  调用 uni.login() 拿到 code
2. 前端               ---->  把 code 发给 你的后端
3. 你的后端           ---->  拿着 code + AppID + AppSecret 去找 微信服务器
4. 微信服务器         ---->  返回 openid 和 session_key 给 你的后端
5. 你的后端           ---->  生成一个 Token (关联 openid)，返回给 前端
6. 前端               ---->  存 Token 到 Storage，以后请求带着它
```

1. **前端获取 Code：**
   首先，在前端调用 uni.login() 方法，获取临时的登录凭证，也就是 **code**。这个 code 有效期很短（5分钟），且只能用一次。
2. **发送给后端：**
   前端拿到 code 后，通过 uni.request 发送给我们的后端服务器。
3. **后端请求微信服务器：**
   后端拿到 code 后，配合小程序后台配置的 **AppID** 和 **AppSecret**，去调用微信官方的 auth.code2Session 接口。
4. **获取 OpenID：**
   微信服务器会验证通过后，返回给后端该用户的 **openid**（用户唯一标识）和 **session_key**（会话密钥）。
   *注意：这里后端一定不能把 session_key 直接返回给前端，有安全风险。*
5. **生成 Token 返回前端：**
   后端利用 openid 在数据库中查找或注册用户，然后生成一个自定义的登录态 **Token**（通常用 JWT），返回给前端。
   前端拿到 Token 后存入 uni.setStorageSync，之后的业务请求都在 Header 里带上这个 Token。”







一个 Symbol 都是独一无二的，即使它们的描述（Description）一样。

```
// 1. 创建 Symbol (注意：不能用 new)
const s1 = Symbol('foo');
const s2 = Symbol('foo');

// 2. 验证唯一性
console.log(s1 === s2); // false (核心考点)

// 3. 获取描述
console.log(s1.description); // "foo"
```

- **面试坑点：** new Symbol() 会报错！因为它是一个原始类型，不是对象，不能 new。

### 作为对象的属性（Key）

这是 Symbol 最主要的作用：**防止属性名冲突**。

假设你在使用一个第三方库的对象 user，你想给它加个 id，但你怕原来的对象里已经有个 id 属性被你覆盖了。这时就用 Symbol。

```
const id = Symbol('id'); // 定义一个唯一的 key

const user = {
  name: 'Tom',
  age: 18,
  [id]: 9527  // 核心语法：用 [变量] 作为 key
};

// 访问
console.log(user[id]); // 9527
console.log(user.id);  // undefined (访问不到，因为 key 不一样)
```

### 半隐形”特性（模拟私有属性）

Symbol 属性具有**“隐藏”**特性，它不会出现在常规的循环中。这在 ES 类私有属性（#）出现之前，常被用来模拟私有属性。

```
const user = {
  name: 'Tom',
  [Symbol('password')]: '123456'
};

// 1. 普通遍历（看不见）
for (let key in user) {
  console.log(key); // 只打印 "name"
}

// 2. Object.keys (看不见)
console.log(Object.keys(user)); // ["name"]

// 3. JSON.stringify (看不见 - 这一点面试必问！)
console.log(JSON.stringify(user)); // '{"name":"Tom"}'

// 4. 怎么获取？(必须用专用 API)
const symKeys = Object.getOwnPropertySymbols(user);
console.log(symKeys[0]); // Symbol(password)

// 5. 终极获取 (Reflect.ownKeys 拿所有)
console.log(Reflect.ownKeys(user)); // ["name", Symbol(password)]
```

------



### 4. 全局共享 Symbol (Symbol.for)

如果你希望在不同的文件里，用同一个描述符拿到**同一个** Symbol，要用 Symbol.for()。

```
// 会在全局注册表中查找，没有就创建，有就返回
const sA = Symbol.for('key');
const sB = Symbol.for('key');

console.log(sA === sB); // true (指向同一个了)
```





JavaScript 中，对象的属性通常分为两类：

1. **“台面上的”属性（String Key）：** 大家都能看见，for 循环能遍历到，转 JSON 也会带上。
2. **“暗箱操作的”属性（Symbol Key）：** 只有知道暗号（拿到那个 Symbol 变量）的人才能访问，普通的遍历和传输都会**自动无视**它。

**看代码证据：**

```
// 1. 定义一个普通的字符串属性
const obj = {
  name: "cm",
  age: 18
};

// 2. 定义一个 Symbol 属性（当作元数据）
const isVip = Symbol("isVip");
obj[isVip] = true; // 标记他是 VIP

// --- 见证奇迹的时刻 ---

// 场景 A：for...in 遍历
for (let key in obj) {
  console.log(key); 
  // 输出：name, age
  // 【结果】：根本看不到 isVip，好像它不存在一样。
}

// 场景 B：给后端传数据 (JSON.stringify)
const jsonString = JSON.stringify(obj);
console.log(jsonString);
// 输出：'{"name":"cm","age":18}'
// 【结果】：Symbol 属性直接被弄丢了！不会被序列化。
```

------



### 2. 为什么要这么做？（实战场景：元数据）

所谓**“元数据” (Metadata)**，就是 **“描述数据的数据”**，或者是 **“仅供前端内部使用的辅助标记”**。

#### ❌ 翻车场景（如果不用 Symbol）：

假设你正在维护一个用户列表，你需要给当前点击的用户加一个 isChecked: true 的高亮标记。

```
// 你的数据对象（准备发给后端的）
let user = { id: 1, name: "Tom" };

// 你为了做高亮效果，随手加了个属性
user.isChecked = true; 

// ... 业务逻辑做完了，你要把这个 user 更新回后端
// 你直接调用了 API
api.updateUser(user);

// 💥 炸了！后端报错：
// "Error: Unknown field 'isChecked'"
// 因为你把前端纯展示用的脏数据，传给了后端数据库。
```

#### ✅ 优雅场景（使用 Symbol）：

你希望这个 isChecked 标记**只在前端逻辑里活着**，发请求的时候**自动消失**，不要污染数据。

```
// 定义一个 Symbol 用来做标记
const IS_CHECKED = Symbol("isChecked");

let user = { id: 1, name: "Tom" };

// 标记高亮
user[IS_CHECKED] = true;

// 在组件里判断高亮（正常读取）
if (user[IS_CHECKED]) {
  renderHighlight();
}

// 发给后端
// JSON.stringify 会自动忽略 Symbol 属性
api.updateUser(JSON.stringify(user)); 

// 🎉 成功！后端收到的只有 {"id":1, "name":"Tom"}
// 那个辅助用的标记自动过滤了，不需要你手动 delete。
```

### 3. 总结

这句话的意思是：
**Symbol 属性就像是给对象贴了一个“隐形标签”。**

- **平时用不到它：** 也就是 for 循环、Object.keys、JSON.stringify 时，这些标签会自动隐藏，保证数据的**纯净性**。
- **专门去读它时：** 也就是你用 obj[sym] 去取值时，它又确确实实存在，能用来控制前端的逻辑（比如高亮、折叠、缓存状态）。





#### user[IS_CHECKED] = true;为什么这个用括号，而user.isChecked这个用点

：**点语法 (.) 和中括号语法 ([]) 的区别**。

一句话结论：
**点语法（.）后面必须跟“字符串字面量”，它不认识变量；**
**中括号语法（[]）里面可以放“变量”，它会先把变量里的值取出来。**

因为 IS_CHECKED 是一个 **变量**（里面存着一个 Symbol），所以必须用 []。





### CJS (CommonJS) vs ESM (ES Modules)

1. sleep 函数返回一个 **Pending（进行中）** 状态的 Promise。
2. await 关键字看到了 Promise，就会**暂停**当前 async 函数的执行，把控制权交还给浏览器（主线程可以去处理点击事件、渲染 UI，不会卡死）。
3. setTimeout 在 N 毫秒后执行 resolve()。
4. Promise 状态变为 **Fulfilled（成功）**。
5. await 收到成功信号，**恢复** async 函数的执行，继续跑下一行代码。







**全局对象（Global Object，你说的 GB）** 是其中最主要的一个根，但它**不是唯一**的起点，甚至**栈（Stack）** 里的变量也是非常重要的起点。

我来把这个过程拆解成**“寻根之旅”**给你看：

### 一、 谁是 GC Roots（起点）？

垃圾回收器开始工作时，它会拿着一份“白名单”，所有在白名单上、或者能顺着白名单找到的对象，都**免死**。找不到的，统统杀掉。

这份白名单（GC Roots）通常包括以下几个地方：

1. **全局对象 (Global Object)：**
   - 在浏览器里是 window，在 Node.js 里是 global。
   - 这是你理解的那个“堆里的老大”。只要挂在 window 下的属性，永远不会被回收（除非你手动设为 null）。
2. **当前执行栈 (Call Stack) 中的变量：** **（重点！这里不在堆里，在栈里）**
   - 这是最容易被忽视的起点。
   - **场景：** 你在一个函数 function test() { let obj = {} } 里。
   - 只要这个函数**正在执行**，这个局部变量 obj 就是一个 **GC Root**。
   - 它存在于**栈内存**的执行上下文中，它指向堆里的 {}。因为函数还在跑，这个对象显然是有用的，不能回收。
3. **闭包中引用的变量：**
   - 如果一个函数里的变量被闭包引用了，即使函数执行完了，这个变量依然会被视为“有根可循”，不会被回收。





```javascript
const el = document.getElementById('box');
console.log(el.clientHeight); // 看得到的高度
console.log(el.offsetHeight); // 实际元素的高度
console.log(el.scrollHeight); // 内容的总高度
```





| 属性           | 描述                     | 读/写                     |
| -------------- | ------------------------ | ------------------------- |
| **scrollTop**  | 元素顶部被“卷上去”的高度 | **可写** (赋值可让它滚动) |
| **scrollLeft** | 元素左侧被“卷进去”的宽度 | **可写**                  |

**判断触底公式（死记）：**

```
// 卷去的高度 + 看到的高度 >= 总内容高度
if (el.scrollTop + el.clientHeight >= el.scrollHeight) {
  console.log("到底了");
}
```

#### 3. 浏览器窗口 (Window/Viewport) 专用

面试官问：“你怎么获取整个页面的滚动距离？”（注意兼容性）

- **页面卷去的高度：**

  ```
  const pageScroll = window.scrollY || document.documentElement.scrollTop;
  ```

- **浏览器窗口可视高度：**

  ```
  const windowHeight = window.innerHeight || document.documentElement.clientHeight;
  ```

  为了**解决浏览器兼容性问题**，俗称“保底写法”。

  **历史背景（浏览器的混战）：**

  1. **现代浏览器（Chrome, Firefox, Safari, Edge）：**
     - 直接提供了 **window.scrollY** 这个属性，最方便，直接能拿到页面滚动的距离。
     - 同时也支持 document.documentElement.scrollTop。
  2. **老版本 IE (IE6/7/8/9)：**
     - **没有** window.scrollY 属性（访问会是 undefined）。
     - 它们认为滚动条是画在 <html> 元素上的，所以要通过 **document.documentElement.scrollTop** 来获取。
  3. **部分特殊的内核或怪异模式（Quirks Mode）：**
     - 有些老旧浏览器认为滚动条是画在 <body> 上的，得用 document.body.scrollTop（不过你这行代码没写这个，通常现在的标准写法前两个就够了）

#### 4. 神器：getBoundingClientRect()

如果面试官问：“怎么判断一个元素是不是出现在屏幕里了？”或者“怎么获取元素距离屏幕左上角的坐标？”。
**必答这个 API！**

```
const rect = el.getBoundingClientRect();

// rect.top:    元素顶部 距离 视口顶部 的距离
// rect.left:   元素左侧 距离 视口左侧 的距离
// rect.bottom: 元素底部 距离 视口顶部 的距离
// rect.width / height: 元素的宽高
```

- **注意：** rect.top 是动态的，随着你滚动页面，这个值会变。