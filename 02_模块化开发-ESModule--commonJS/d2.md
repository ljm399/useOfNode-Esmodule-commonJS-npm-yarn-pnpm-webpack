#  一. 模块化开发:

-  把程序划分为一个个小的结构
-  每个结构有其他逻辑代码与作用域,
-  同时这个结构可以把自己希望的变量,函数,对象导出给其他模块使用,
-  也可以导入其他模块的变量,函数,对象

-  有commonJS和ESmodule两种方式





## commonJS

- commonJS(CJS)是个规范,早期叫serverJS(运行在服务器),后来广泛使用才叫CommonJS

#### CommonJS导入与导出:

- exports(导出方式一)
  - exports.name = name
- module.exports(导出方式二)
  - module.exports.name = name



- require(导入)



#### exports和module.exports区别

- 实现模块导出,node使用的是Modules类,即创建的文件(xx.js),都是这个类的实例

- 默认引用赋值指向同一个对象,其他的文件无论通过exports还是modules.exports都可以来获取导出对象的内容

- 但当后者指向一个新对象,exports则没有任何意义,外部文件无法使用,只能通过modules.exports

  - module.exports = {

    ​           name : name

    }(指向个新对象)

- exports意义

  - 因为commoJS没有modules.exports这个规范
  - 让其等于exports就有规范了



#### require导入的查找规则

​	require("A")

1. 优先找A是否内置模块

2. 情况二

   - 现在当前文件夹找,要是其没有后缀名,给其加

   1. js
   2. json
   3. .node

   - 要是没有找到,把其当成文件夹,先查找

   1. 其目录下的index.js
   2. index.json
   3. index.node

3. 在node_module按情况二的方式再找一遍,如果没找到,就报错

4. require查找node_module规则

   ![](D:\Desktop\JavaScript\06_node-Esmodule-webpack-git\01_node的基本使用\node-module查找规则.png)

   - 逐渐找的根目录



### 模块的加载过程

- 第一次引用(require),默认加载一次
- 当同一模块多次引用,只运行一次
  - 因为每个模块有个属性:loaded
  - 当加载过一次,其值由false变为true,则该模块会缓存但只运行一次
- 如果一个模块有循环引用
  - ![](D:\Desktop\JavaScript\06_node-Esmodule-webpack-git\01_node的基本使用\模块加载.png)
    - 这在数据结构叫图结构
    - 当树结构的子类指向其他子类,就由树结构变为图结构(如上图)
    - 图结构有深度优先搜索和广度优先搜索
  - Node是深度优先搜索:main->aaa->ccc->ddd->eee->bbb



### commonJS优缺点

- 加载代码是同步的

- 适用于服务器,因为服务器里面的文件都是本地引用

- 但在浏览器,则要不断地去服务区下载文件,效率低

- 所以浏览器不是用commonJS,而是ESmodule或webpack

  - 使用webpack则不管使用ESmodule和commonJS都可以
  - 因为他会对源文件打包,解析为浏览器认识的代码

- 以前是使用AMD和CMD,现在不用了(了解)

  - 二者是论坛的规范而不是要求

  - ESmoduel思想和其差不多,但是官网推出

  - AMD解决commonJS问题核心

    - require.js

  - CMD

    - Sea.js

    

# 二. ES module(官网推出)

- 自动采用use strict模式
- 在浏览器中加载(.html引入)

  - xx.html > script .type=module
  - 上面(commjs/AMD/CMD)的代码没有要用到.html文件,因为用node加载而不是浏览器
- 核心

  - export(没有s,commonJS是exports/module.exports)
  - import
  - 

### 注意:

1. export后面的{}不是对象,而是标识符,告诉浏览器要放进模块环境变量的名字

```
const name = codecao
funciton age() {}
export {
	name,
	age
}
```

2. 要开启live serve来加载html文件,因为ESmodule协议需要

3. 导入的文件后缀名不能少

   ```
   // import {fn} from './fn.js'//.js不能少
   ```

   

​	     



### 导出和导入的三种方式

- 导出

  1. export  const name = 'codecao'

  2. ```
     export {
     	name,
     	age
     }
     ```

  3. 起别名

     ```
     export {
     	name as codecao,
     	age
     }
     则其他文件要import {codecao age} form 'xx'
     ```

- 导入(3种方式)

  1. import { name ,age} form 'xx.js'

  2. import { name as fname ,age} form 'xx.js'

     ```
     clg(fname)
     ```

  3. import * as foo form 'xx.js'

     ```
     clg(foo.name)
     ```

### 思想

- 把多个.js文件,导入到本地的index文件中,然后由该文件一键导出

  - 一键导出(在index.js文件中)

  - ```
    //方式一
    // import {fn} from './fn.js'
    // import {name} from './foo.js'
    
    // export {fn, name}
    
    //方式二
    // export {fn} from  './fn.js'
    // export {name} from './foo.js'
    
    // 方式三(少用,因为不知道具体导出哪些内容,容易造成混乱)
    // export * from './fn.js'
    // export * from './foo.js'
    
    ```

  - 记得还有在创建个.js文件比如main.js,用于导入,而不是直接在html文件中导入index.js文件

    - ```
      <script src="./main.js" type="module"></script>
      <script>
        // console.log(codecao)//codecao is not defined,因为ESmodule的特性，顶层代码只在模块执行时运行一次，所以顶层变量只在第一次运行时被赋值。而module的src是异步,所有undefined
      ```

​			

### 默认导出和导入

- 注意一个文件只能有一个默认导出(default)

```
// function parselyric() {
//   return '歌词解析模块'
// }
// //  默认导出
// 1.1
// export default parselyric

// 1.2 
export default function parselyric() {
  return '歌词解析模块'
}
```

- 导入到main.js

  - ````
    import a from './lyric.js'(导入的名字是任意)
    console.log(a())
    ````

  - 记得在html文件导入main.js

    - ```
        <script src="./main.js" type="module"></script>
      ```



### 条件判断是否导入

- import函数,返回promise

```
let flag = true
if (flag) {
  const importlyric = import('./lyric.js')
  const foo = import('./foo.js')
  //拿到默认导出的返回值
  importlyric.then((res) => {
    console.log(res.default())
  })
  //拿到具名导出的返回值
  foo.then((res) => {
    console.log(res.name)
  })
}
```

- 不能是import a from './lyric.js'原因
  - 因为在执行代码前就要先解析导入的文件
  - if是执行代码才会执行后续代码



### meta(了解)-ES11新属性

```
console.log(import.meta)//{url: 'http://127.0.0.1:5500/02/ES-module/02_%E6%9D%A1%E4…90%A6%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/main.js', resolve: ƒ}
```





### 默认导入原理

1. 构建阶段

   ![](D:\Desktop\JavaScript\06_node-Esmodule-webpack-git\02_模块化开发-ESModule--commonJS\模块导入原理1.png)

   - 映射关系作用
     - 到下次导入回去映射表看,有则直接本地下载,否则去服务器下载

​	



2. 实例化和第三步运行代码

   ![](D:\Desktop\JavaScript\06_node-Esmodule-webpack-git\02_模块化开发-ESModule--commonJS\模块导入原理2.png)

- 第三部才运行代码
  - 所以if判断这行再导入文件会报错
  - 同时import x from 'index' + ''.js' 给导入文件运算也报错,原理一样

- export {}的{}不是对象,而是告诉JS引擎你要放入module Environment Record对象的标识符如(name,foo)
  - {}是一种特殊的语法,但不是对象,不可以export {name: name}







